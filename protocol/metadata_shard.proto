syntax = "proto3";
package river.metadata;
option go_package = "github.com/towns-protocol/towns/core/node/protocol";

// StreamMetadata is the stream state stored in a metadata shard.
message StreamMetadata {
    // Stream id.
    // Must be 32 bytes.
    bytes stream_id = 1;

    // Hash of the last miniblock.
    // Must be 32 bytes.
    bytes last_miniblock_hash = 2;

    // Last miniblock height.
    int64 last_miniblock_num = 3;

    // Nodes hosting the stream.
    // Must be 20 bytes records.
    // Nodes array is ordered:
    // - first replication_factor nodes are quorum nodes for the stream.
    // - remaining nodes are follow nodes that replicate the stream, but do not vote on miniblocks.
    // Should contain at least replication_factor nodes.
    repeated bytes nodes = 4;

    // Replication factor for the stream.
    // Must be greater than 0.
    // First replication_factor nodes are quorum nodes for the stream.
    // Remaining nodes are follow nodes that replicate the stream, but do not vote on miniblocks.
    // Should be less than or equal to the number of nodes.
    uint32 replication_factor = 5;

    // Whether the stream is sealed.
    // When stream is sealed, last miniblock hash and number are immutable.
    // Both replication factor and nodes can be updated when stream is sealed.
    bool sealed = 8;
}

// MetadataTx is the envelope for all metadata shard transactions.
message MetadataTx {
    oneof op {
        CreateStreamTx create_stream = 1;
        SetStreamLastMiniblockBatchTx set_stream_last_miniblock_batch = 2;
        UpdateStreamNodesAndReplicationTx update_stream_nodes_and_replication = 3;
    }
}

// CreateStreamTx initializes a stream record on a metadata shard.
// This transaction is used for creating new steams with genesis miniblocks,
// promoting ephemeral streams to permanent streams, and for migrating streams
// from legacy StreamRegistry smart contract.
message CreateStreamTx {
    StreamMetadata stream = 1;
}

// SetStreamLastMiniblockBatchTx updates miniblock pointers for multiple streams atomically.
message SetStreamLastMiniblockBatchTx {
    repeated MiniblockUpdate miniblocks = 1;
}

// MiniblockUpdate updates the last miniblock for a stream.
message MiniblockUpdate {
    // Stream id.
    // Must be 32 bytes.
    bytes stream_id = 1;

    // Last known miniblock hash before applying this update.
    // Must be 32 bytes.
    // Must be for the last known miniblock in the stream.
    bytes prev_miniblock_hash = 2;

    // New miniblock height.
    // Must be greater than the last known miniblock height by 1.
    int64 last_miniblock_num = 3;

    // New miniblock hash.
    // Must be 32 bytes.
    bytes last_miniblock_hash = 4;

    // Mark stream sealed at this height if true.
    bool sealed = 5;
}

// UpdateStreamNodesAndReplicationTx updates placements and/or replication factor.
message UpdateStreamNodesAndReplicationTx {
    // Stream id.
    // Must be 32 bytes.
    bytes stream_id = 1;

    // Optional full node set to apply for the stream.
    // If empty, keep current nodes.
    // Replaces existing nodes for the stream.
    // Must be 20 bytes records.
    // Nodes array is ordered:
    // - first replication_factor nodes are quorum nodes for the stream.
    // - remaining nodes are follow nodes that replicate the stream, but do not vote on miniblocks.
    repeated bytes nodes = 2;

    // Optional replication factor change. If 0, keep current.
    uint32 replication_factor = 3;
}

// ValidatorLastSignState stores the last signed state of a validator.
message ValidatorLastSignState {
    int64 height = 1;
    int32 round = 2;
    int32 step = 3;
    bytes signature = 4;
    bytes signed_bytes = 5;
}