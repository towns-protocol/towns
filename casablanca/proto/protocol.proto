syntax = "proto3";
package casablanca;
option go_package = "casablanca/node/protocol";

// TODO: fix comments

/**
 * Envelope contains serialized event, and its hash and signature.
 * hash is used as event id. Subsequent events reference this event by hash.
 */
message Envelope {
    /**
     * Hash of event.
     * While hash can be recalculated from the event, having it here explicitely
     * makes it easier to work with event.
     * For the event to be valid, must match hash of event field. 
     */
    bytes hash = 1;

    /**
     * Signature.
     * For the event to be valid, signature must match event.creator_address
     * or be signed by the address from evant.delegate_sig.
     */
    bytes signature = 2;

    bytes event = 3;
}

message StreamEvent {
    /**
     * Address of the creator of the event.
     * For user - address of the user's Towns wallet.
     * For server - address of the server's keypair in staking smart contract.
     *
     * For the event to be valid:
     * If delegate_sig is present, creator_address must match delegate_sig.
     * If delegate_sig is not present, creator_address must match event signature in the Envelope.
     */
    bytes creator_address = 1;

     /**
      * delegate_sig allows event to be signed by device keypair 
      * which is linked to the user's Towns wallet.
      *
      * delegate_sig constains signature of the public key of the device keypair.
      * User's Towns wallet is used to produce this signature.
      * 
      * If present, for the event to be valid:
      * 1. creator_address must match delegate_sig's signer public key
      * 2. delegate_sig should be the signature of Envelope.signature's public key.
      *
      * Server nodes sign node-produced events with their own keypair and do not
      * need to use delegate_sig.
      */
    bytes delegate_sig = 2;
 
    /** Salt ensures that similar messages are not hashed to the same value. genId() from id.ts may be used. */
    /** TODO: move salt to inception event */
    bytes salt = 3;
 
    /** Hashes of the preceding leaf events in the stream. Empty array for the inception event. */
    repeated bytes prev_events = 4;
 
    /** Variable-type payload. 
      * Payloads should obey the following rules:
      * - payloads should have their own unique type
      * - each payload should have a oneof content field
      * - each payload should have an inception field inside the content oneof
      * - each payload should have a unique Inception type
      * - payloads can't violate previous type recursively to inception payload
    */
    oneof payload {
        SpacePayload space_payload = 100;
        ChannelPayload channel_payload = 101;
        UserPayload user_payload = 102;
        UserSettingsPayload user_settings_payload = 103;
        UserDeviceKeyPayload user_device_key_payload = 104;
    }
}

/**
 * Derived event is produces by server when there should be additional event to compliment
 * received event. For example, when user joins a space through event in the space stream, server will produce a derived event
 * in a user stream to indicate that user joined a particual space.
 *
 * EventRef is used to reference the event that caused the derived event to be produced.
 */
message EventRef {
    string stream_id = 1;
    bytes hash = 2;
    bytes signature = 3;
}


message Membership {
    MembershipOp op = 1;
    string user_id = 2;
}


message UserPayload {
    message Inception {
        string stream_id = 1;
    }
    
    message UserMembership {
        string stream_id = 1;
        EventRef origin_event = 2;
        string inviter_id = 3;
        MembershipOp op = 4;
    }
    
    message ToDevice {
        ToDeviceOp op = 1;
        bytes value = 2;
        string device_id = 3;
    }
    
    oneof content {
        Inception inception = 1;
        UserMembership user_membership = 2;
        ToDevice to_device = 3;
    }
}


message SpacePayload {
    message Inception {
        string stream_id = 1;
    }

    message Channel {
        ChannelOp op = 1;
        string channel_id = 2;
        EventRef origin_event = 3;
    }

    oneof content {
        Inception inception = 1;
        Channel channel = 2;
        Membership membership = 3;
    }
}

message ChannelPayload {
    message Inception {
        string stream_id = 1;
        string space_id = 3;
    }

    message Message {
        string text = 1;
    }

    oneof content {
        Inception inception = 1;
        Message message = 2;
        Membership membership = 3;
    }
}

message UserSettingsPayload {
    message Inception {
        string stream_id = 1;
        string space_id = 3;
    }

    message UserSetting {
        UserSettingOp op = 1;
        bytes value = 2;
        optional string channel_id = 3;
        optional EventRef origin_event = 4;
    }

    oneof content {
        Inception inception = 1;
        UserSetting user_setting = 2;
    }
}

message UserDeviceKeyPayload {
    message Inception {
        string stream_id = 1;
        string user_id = 2;
    }

    message UserDeviceKey {
        string user_id = 1;
        optional DeviceKeys device_keys = 2;
        optional FallbackKeys fallback_keys = 3;
    }

    oneof content {
        Inception inception = 1;
        UserDeviceKey user_device_key = 2;
    }
}

enum MembershipOp {
    SO_UNSPECIFIED = 0;
    SO_INVITE = 1;
    SO_JOIN = 2;
    SO_LEAVE = 3;
}

enum ChannelOp {
    CO_UNSPECIFIED = 0;
    CO_CREATED = 1;
    CO_DELETED = 2;
}

enum UserSettingOp {
    USO_UNSPECIFIED = 0;
    USO_FULLY_READ = 1;
}

enum ToDeviceOp {
    TDO_UNSPECIFIED = 0;
    TDO_TO_DEVICE = 1;
}

/**
* DeviceKeys are used to store public identity keys and signatures for a particular
* user's device. 
* 
* algorithms: encryption algorithms supported by the device.
* keys: public identity keys (signing keys) for the device with property in format <algorithm>:<device_id>.
*       Keys should be encoded as specified by key algorithm. 
* signatures: map from <algorithm>:<device_id> to signature. 
*/
message DeviceKeys {
    string device_id = 1;
    repeated string algorithms = 2;
    map<string, string> keys = 3;
    map<string, string> signatures = 4;
}

/**
* FallbackKeys are used to store "pre-key" messages for a particular user's device.
*
* algo_key_id: map from <algorithm>:<key_id> to Key.
*/
message FallbackKeys {
    map<string, Key> algo_key_id = 1;
}

/**
* Key is used to store fallback keys and depending on the algorithm signatures
* that are formatted as <algorithm>:<device_id> mapped to <signature>
*
* key: key value
* signatures: map from <algorithm>:<device_id> to signature for given key.
*/
message Key {
    string key = 1;
    map<string, string> signatures = 2;
}

message StreamAndCookie {
    repeated Envelope events = 1;
    bytes next_sync_cookie = 2;
    bytes original_sync_cookie = 3;
    string stream_id = 4;
}

message CreateStreamRequest {
    repeated Envelope events = 1;
}

message CreateStreamResponse {
    bytes sync_cookie = 1;
}

message GetStreamRequest {
    string stream_id = 1;
}

message GetStreamResponse {
    StreamAndCookie stream = 1;
}

message AddEventRequest {
    string stream_id = 1;
    Envelope event = 2;
}

message AddEventResponse {}

message SyncPos {
    string stream_id = 1;
    bytes sync_cookie = 2;
}

message SyncStreamsRequest {
    repeated SyncPos sync_pos = 1;
    uint32 timeout_ms = 2;
}

message SyncStreamsResponse {
    repeated StreamAndCookie streams = 1;
}

message InfoRequest {
    string debug = 1;
}

message InfoResponse {
    string graffiti = 1;
}

service StreamService {
    rpc CreateStream(CreateStreamRequest) returns (CreateStreamResponse);
    rpc GetStream(GetStreamRequest) returns (GetStreamResponse);
    rpc AddEvent(AddEventRequest) returns (AddEventResponse);
    rpc SyncStreams(SyncStreamsRequest) returns (stream SyncStreamsResponse);
    rpc Info(InfoRequest) returns (InfoResponse);
}

enum Err {
    ERR_UNSPECIFIED = 0;
    DEBUG_ERROR = 1;
    BAD_STREAM_ID = 2;
    BAD_STREAM_CREATION_PARAMS = 3;
    STREAM_ALREADY_EXISTS = 4;
    INTERNAL_ERROR_SWITCH = 5;
    BAD_EVENT_ID = 6;
    BAD_EVENT_SIGNATURE = 7;
    BAD_HASH_FORMAT = 8;
    BAD_PREV_EVENTS = 9;
    NO_EVENT_SPECIFIED = 10;
    BAD_EVENT = 11;
    USER_CANT_POST = 12;
    STREAM_NOT_FOUND = 13;
    STREAM_BAD_HASHES = 14;
    STREAM_EMPTY = 15;
    STREAM_BAD_EVENT = 16;
    BAD_DELEGATE_SIG = 17;
    BAD_PUBLIC_KEY = 18;
    BAD_PAYLOAD = 19;
    BAD_HEX_STRING = 20;
    BAD_EVENT_HASH = 21;
}
