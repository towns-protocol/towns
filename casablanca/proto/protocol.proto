syntax = "proto3";
package river;
option go_package = "casablanca/node/protocol";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";


/** 
* Miniblock contains a list of events and the header event.
* Events must be in the same order as in the header, which is of type MiniblockHeader.
* Only signed data (Envelopes) should exist in this data structure.
*/
message Miniblock {
    repeated Envelope events = 1;
    Envelope header = 2;
}

/**
 * Envelope contains serialized event, and its hash and signature.
 * hash is used as event id. Subsequent events reference this event by hash.
 * event is a serialized StreamEvent
 */
message Envelope {
    /**
     * Hash of event.
     * While hash can be recalculated from the event, having it here explicitely
     * makes it easier to work with event.
     * For the event to be valid, must match hash of event field. 
     */
    bytes hash = 1;

    /**
     * Signature.
     * For the event to be valid, signature must match event.creator_address
     * or be signed by the address from evant.delegate_sig.
     */
    bytes signature = 2;

    bytes event = 3;
}

/**
* StreamEvent is a single event in the stream.
*/
message StreamEvent {
    /**
     * Address of the creator of the event.
     * For user - address of the user's Towns wallet.
     * For server - address of the server's keypair in staking smart contract.
     *
     * For the event to be valid:
     * If delegate_sig is present, creator_address must match delegate_sig.
     * If delegate_sig is not present, creator_address must match event signature in the Envelope.
     */
    bytes creator_address = 1;

     /**
      * delegate_sig allows event to be signed by device keypair 
      * which is linked to the user's Towns wallet.
      *
      * delegate_sig constains signature of the public key of the device keypair.
      * User's Towns wallet is used to produce this signature.
      * 
      * If present, for the event to be valid:
      * 1. creator_address must match delegate_sig's signer public key
      * 2. delegate_sig should be the signature of Envelope.signature's public key.
      *
      * Server nodes sign node-produced events with their own keypair and do not
      * need to use delegate_sig.
      */
    bytes delegate_sig = 2;
 
    /** Salt ensures that similar messages are not hashed to the same value. genId() from id.ts may be used. */
    /** TODO: move salt to inception event */
    bytes salt = 3;
 
    /** Hashes of the preceding leaf events in the stream. Empty array for the inception event. */
    repeated bytes prev_events = 4;
 
    /** CreatedAt is the time when the event was created.
    NOTE: this value is set by clients and is not reliable for anything other than displaying
    the value to the user. Never use this value to sort events from different users.  */
    int64 created_at_epoc_ms = 5;
    
    /** Variable-type payload. 
      * Payloads should obey the following rules:
      * - payloads should have their own unique type
      * - each payload should have a oneof content field
      * - each payload should have an inception field inside the content oneof
      * - each payload should have a unique Inception type
      * - payloads can't violate previous type recursively to inception payload
    */
    oneof payload {
        MiniblockHeader miniblock_header = 100;
        SpacePayload space_payload = 101;
        ChannelPayload channel_payload = 102;
        UserPayload user_payload = 103;
        UserSettingsPayload user_settings_payload = 104;
        UserDeviceKeyPayload user_device_key_payload = 105;
        MediaPayload media_payload = 106;
        DmChannelPayload dm_channel_payload = 107;
        GdmChannelPayload gdm_channel_payload = 108;
    }
}

/** 
* MiniblockHeader is a special event that forms a block from set of the stream events.
* Hash of the serialized StreamEvent containing MiniblockHeader is used as a block hash.
*/
message MiniblockHeader {
    // Miniblock number.
    // 0 for genesis block.
    // Must be 1 greater than the previous block number.
    int64 miniblock_num = 1;

    // Hash of the previous block.
    bytes prev_miniblock_hash = 2;

    // Timestamp of the block.
    // Must be greater than the previous block timestamp.
    google.protobuf.Timestamp timestamp = 3;

    // Hashes of the events included in the block.
    repeated bytes event_hashes = 4;

    // Snapshot of the state at the end of the block.
    optional Snapshot snapshot = 5;

    // count of all events in the stream before this block
    int64 event_num_offset = 6;

    // pointer to block with previous snapshot
    int64 prev_snapshot_miniblock_num = 7;

    // stream payloads are required to have a content field
    oneof content {
        google.protobuf.Empty none = 100;
    }
}

/**
* SpacePayload
*/
message SpacePayload {
    message Snapshot {
        // inception
        Inception inception = 1;
        // streamId: Channel
        map<string, Channel> channels = 2;
        // userId: Membership
        map<string, Membership> memberships = 3;
        // userId: Username
        map<string, WrappedEncryptedData> usernames = 4;
        // userId: Displayname
        map<string, WrappedEncryptedData> display_names = 5;
    }
    
    message Inception {
        string stream_id = 1;
        StreamSettings settings = 2;
    }

    message Channel {
        ChannelOp op = 1;
        string channel_id = 2;
        EventRef origin_event = 3;
        EncryptedData channel_properties = 4;
    }

    message WrappedEncryptedData {
        EncryptedData data = 1;
        int64 event_num = 2;
    }

    oneof content {
        Inception inception = 1;
        Channel channel = 2;
        Membership membership = 3;
        EncryptedData username = 4;
        EncryptedData display_name = 5;
    }
}

/**
* ChannelPayload
*/
message ChannelPayload {
    message Snapshot {
        // inception
        Inception inception = 1;
        // userId: Membership
        map<string, Membership> memberships = 2;
    }
    
    message Inception {
        string stream_id = 1;
        string space_id = 3;
        /**
        * channel_name and channel_topic from this payload will be used to 
        * create associated with that channel space event for stream as we agreed
        * that channel names and topics will be delivered using space stream
        */
        EncryptedData channel_properties = 4;
        StreamSettings settings = 5;
    }

    oneof content {
        Inception inception = 1;
        EncryptedData message = 2;
        Membership membership = 3;
        Fulfillment fulfillment = 4;
        KeySolicitation key_solicitation = 5;
    }
}

/**
* DmChannelPayload
*/
message DmChannelPayload {
    message Snapshot {
        Inception inception = 1;
        map<string, Membership> memberships = 2;
    }

    message Inception {
        string stream_id = 1;
        string first_party_id = 2;
        string second_party_id = 3;
        StreamSettings settings = 4;
    }

    oneof content {
        Inception inception = 1;
        Membership membership = 2;
        EncryptedData message = 3;
        Fulfillment fulfillment = 4;
        KeySolicitation key_solicitation = 5;
    }
}

/**
* GdmChannelPayload
*/
message GdmChannelPayload {
    message Snapshot {
        Inception inception = 1;
        map<string, Membership> memberships = 2;
    }

    message Inception {
        string stream_id = 1;
        EncryptedData channel_properties = 2;
        StreamSettings settings = 3;
    }

    oneof content {
        Inception inception = 1;
        Membership membership = 2;
        EncryptedData message = 3;
        Fulfillment fulfillment = 4;
        KeySolicitation key_solicitation = 5;
    }
}

/**
* UserPayload
*/
message UserPayload {
    message Snapshot {
        // inception
        Inception inception = 1;
        // streamId: UserMembership
        map<string, UserMembership> memberships = 2;
    }

    message Inception {
        string stream_id = 1;
        StreamSettings settings = 2;
    }
    
    message UserMembership {
        string stream_id = 1;
        EventRef origin_event = 2;
        string inviter_id = 3;
        MembershipOp op = 4;
    }
    
    message ToDevice {
        ToDeviceOp op = 1;
        EncryptedDeviceData message = 2;
        string device_key = 3;
        string sender_key = 4;
    }
    
    oneof content {
        Inception inception = 1;
        UserMembership user_membership = 2;
        ToDevice to_device = 3;
    }
}

/**
* KeySolicitation messages are used to request keys pertaining to a given session,
* stream and optional algorithm. For now, algorithm is megolm, but this can change.
*/
message KeySolicitation {
    string session_id = 1;
    string algorithm = 2;
    // known session ids
    repeated string known_session_ids = 3;
    string sender_key = 4;
}

/**
* Fulfillment is used to acknowledge that the event depicted by event hash
* was responded to by a device over secure to device communication
* with the requested session.
* Used to prevent spurious processing of key requests
* by multiple requested users' devices.
*/
message Fulfillment {
    bytes origin_hash = 1; // origin KeySolicitation event hash
    repeated string session_ids = 2;
    optional string algorithm = 3;
}

/**
* UserSettingsPayload
*/
message UserSettingsPayload {
    message Snapshot {
        // inception
        Inception inception = 1;
        // channelStreamId: FullyReadMarker
        map<string, FullyReadMarkers> fully_read_markers = 2;
    }

    message Inception {
        string stream_id = 1;
        StreamSettings settings = 2;
    }

    message FullyReadMarkers {
        string channel_stream_id = 1;
        EncryptedData content = 2;
    }

    oneof content {
        Inception inception = 1;
        FullyReadMarkers fully_read_markers = 2;
    }
}

/**
* UserDeviceKeyPayload
*/
message UserDeviceKeyPayload {
    message Snapshot {
        // inception
        Inception inception = 1;
        // deviceId: UserDeviceKey
        map<string, UserDeviceKey> user_device_keys = 2;
    }

    message Inception {
        string stream_id = 1;
        string user_id = 2;
        StreamSettings settings = 3;
    }

    message UserDeviceKey {
        string user_id = 1;
        DeviceKeys device_keys = 2;
        FallbackKeys fallback_keys = 3;
    }

    oneof content {
        Inception inception = 1;
        UserDeviceKey user_device_key = 2;
    }
}

/**
* MediaPayload
*/
message MediaPayload {
    message Snapshot {
        Inception inception = 1;
    }
    
    message Inception {
        string stream_id = 1;
        string channel_id = 2;
        int32 chunk_count = 3;
        StreamSettings settings = 4;
    }

    message Chunk {
        bytes data = 1;
        int32 chunk_index = 2;
    }

    oneof content {
        Inception inception = 1;
        Chunk chunk = 2;
    }
}

/**
* Snapshot contains a summary of all state events up to the most recent miniblock
*/
message Snapshot {
    // Snapshot data specific for each stream type.
    oneof content {
        SpacePayload.Snapshot space_content = 101;
        ChannelPayload.Snapshot channel_content = 102;
        UserPayload.Snapshot user_content = 103;
        UserSettingsPayload.Snapshot user_settings_content = 104;
        UserDeviceKeyPayload.Snapshot user_device_key_content = 105;
        MediaPayload.Snapshot media_content = 106;
        DmChannelPayload.Snapshot dm_channel_content = 107;
        GdmChannelPayload.Snapshot gdm_channel_content = 108;
    }
}

/**
 * Derived event is produces by server when there should be additional event to compliment
 * received event. For example, when user joins a space through event in the space stream, server will produce a derived event
 * in a user stream to indicate that user joined a particual space.
 *
 * EventRef is used to reference the event that caused the derived event to be produced.
 */
message EventRef {
    string stream_id = 1;
    bytes hash = 2;
    bytes signature = 3;
}

/**
 * StreamSettings is a part of inception payload for each stream type.
 */
message StreamSettings {
    // This setting controls block production rate for a given stream.
    // It is used for testing and is used only by nodes running in test mode.
    uint64 miniblock_time_ms = 1;
    // Minimum number of events before we take a snapshot
    int32 min_events_per_snapshot = 2;
}


message Membership {
    MembershipOp op = 1;
    string user_id = 2;
}


message EncryptedData {
    /**
    * Ciphertext of the encryption envelope.
    */
    string text = 1;
    /**
    * Encryption algorithm  used to encrypt this event.
    */
    optional string algorithm = 2;
    /**
    * Sender device public key identifying the sender's device.
    */
    optional string sender_key = 3;
    /**
    * Sender's device id.
    */
    optional string device_id = 4;
    /**
    * The ID of the session used to encrypt the message.
    */
    optional string session_id = 5;
}

message EncryptedDeviceData {
    /**
    * Mapping from device identifier to encryption envelope.
    */
    map<string, EncryptedMessageEnvelope> ciphertext = 1;
    /**
    * Encryption algorithm  used to encrypt this event.
    */
    optional string algorithm = 2;
}

message EncryptedMessageEnvelope {
    // Either 0 for pre-key messages or 1 after session is established.
    int32 type = 1;
    /**
    * Ciphertext of the encryption envelope.
    */
    string body = 2;
}

/**
* DeviceKeys are used to store public identity keys and signatures for a particular
* user's device. 
* 
* device_id: unique identifier for the device - River hash over RDK public part.
* algorithms: encryption algorithms supported by the device.
* keys: public identity keys (signing keys) for the device with property in format <algorithm>:<device_id>.
*       Keys should be encoded as specified by key algorithm. 
* signatures: map from <algorithm>:<device_id> to signature. 
*/
message DeviceKeys {
    string device_id = 1;
    repeated string algorithms = 2;
    map<string, string> keys = 3;
    map<string, string> signatures = 4;
}

/**
* FallbackKeys are used to store "pre-key" messages for a particular user's device.
*
* algo_key_id: map from <algorithm>:<key_id> to Key.
*/
message FallbackKeys {
    map<string, Key> algo_key_id = 1;
}

/**
* Key is used to store fallback keys and depending on the algorithm signatures
* that are formatted as <algorithm>:<device_id> mapped to <signature>
*
* key: key value
* signatures: map from <algorithm>:<device_id> to signature for given key.
*/
message Key {
    string key = 1;
    map<string, string> signatures = 2;
}

message SyncCookie  {
    string node_address = 1;
    string stream_id = 2;
    int64 minipool_gen = 3;
    int64 minipool_slot = 4;
    bytes prev_miniblock_hash = 5;
}

message StreamAndCookie {
    repeated Envelope events = 1;
    SyncCookie next_sync_cookie = 2;
    SyncCookie start_sync_cookie = 3;
}

message CreateStreamRequest {
    repeated Envelope events = 1;
    string stream_id = 2; // stream_id should match the stream_id in the inception payload of the first event
 }

message CreateStreamResponse {
    // all events in current minipool and cookie allowing to sync from the end of the stream
    StreamAndCookie stream = 1;
    // all blocks since the latest snapshot, miniblocks[0].header is the latest snapshot
    repeated Miniblock miniblocks = 2;
}

message GetStreamRequest {
    string stream_id = 1;
}

message GetStreamResponse {
    // all events in current minipool and cookie allowing to sync from the end of the stream
    StreamAndCookie stream = 1;
    // all blocks since the latest snapshot, miniblocks[0].header is the latest snapshot
    repeated Miniblock miniblocks = 2;
}

message GetMiniblocksRequest {
    string stream_id = 1;
    int64 fromInclusive = 2;
    int64 toExclusive = 3;
}

message GetMiniblocksResponse {
    repeated Miniblock miniblocks = 1;
    // terminus: true if there are no more blocks to fetch because they've been garbage collected, or you've reached block 0
    bool terminus = 2;
}

message GetLastMiniblockHashRequest {
    string stream_id = 1;
}

message GetLastMiniblockHashResponse {
    bytes hash = 1;
    int64 miniblock_num = 2;
}

message AddEventRequest {
    string stream_id = 1;
    Envelope event = 2;
}

message AddEventResponse {}

message SyncStreamsRequest {
    repeated SyncCookie sync_pos = 1;
}

message SyncStreamsResponse {
    StreamAndCookie stream = 1;
    string sync_id = 2;
}

message AddStreamsToSyncRequest {
    repeated SyncCookie sync_pos = 1;
    string sync_id = 2;
}

message AddStreamsToSyncResponse {}

message RemoveStreamsFromSyncRequest {
    repeated string stream_id = 1;
}

message RemoveStreamsFromSyncResponse {}

message InfoRequest {
    string debug = 1;
}

message InfoResponse {
    string graffiti = 1;
}

service StreamService {
    rpc CreateStream(CreateStreamRequest) returns (CreateStreamResponse);
    rpc GetStream(GetStreamRequest) returns (GetStreamResponse);
    rpc GetMiniblocks(GetMiniblocksRequest) returns (GetMiniblocksResponse);
    rpc GetLastMiniblockHash(GetLastMiniblockHashRequest) returns (GetLastMiniblockHashResponse);
    rpc AddEvent(AddEventRequest) returns (AddEventResponse);
    rpc SyncStreams(SyncStreamsRequest) returns (stream SyncStreamsResponse);
    rpc AddStreamsToSync(AddStreamsToSyncRequest) returns (AddStreamsToSyncResponse);
    rpc RemoveStreamsFromSync(RemoveStreamsFromSyncRequest) returns (RemoveStreamsFromSyncResponse);
    rpc Info(InfoRequest) returns (InfoResponse);
}


enum MembershipOp {
    SO_UNSPECIFIED = 0;
    SO_INVITE = 1;
    SO_JOIN = 2;
    SO_LEAVE = 3;
}

enum ChannelOp {
    CO_UNSPECIFIED = 0;
    CO_CREATED = 1;
    CO_DELETED = 2;
    CO_UPDATED = 4;
}

enum ToDeviceOp {
    TDO_UNSPECIFIED = 0;
    TDO_KEY_REQUEST = 1;
    TDO_KEY_RESPONSE = 2;
}

// Codes from 1 to 16 match gRPC/Connect codes.
enum Err {
    ERR_UNSPECIFIED = 0;

    // Canceled indicates that the operation was canceled, typically by the
	// caller.
    CANCELED = 1;

	// Unknown indicates that the operation failed for an unknown reason.
	UNKNOWN = 2;

	// InvalidArgument indicates that client supplied an invalid argument.
	INVALID_ARGUMENT  = 3;

	// DeadlineExceeded indicates that deadline expired before the operation
	// could complete.
	DEADLINE_EXCEEDED  = 4;

	// NotFound indicates that some requested entity (for example, a file or
	// directory) was not found.
	NOT_FOUND  = 5;

	// AlreadyExists indicates that client attempted to create an entity (for
	// example, a file or directory) that already exists.
	ALREADY_EXISTS  = 6;

	// PermissionDenied indicates that the caller doesn't have permission to
	// execute the specified operation.
	PERMISSION_DENIED  = 7;

	// ResourceExhausted indicates that some resource has been exhausted. For
	// example, a per-user quota may be exhausted or the entire file system may
	// be full.
	RESOURCE_EXHAUSTED  = 8;

	// FailedPrecondition indicates that the system is not in a state
	// required for the operation's execution.
	FAILED_PRECONDITION  = 9;

	// Aborted indicates that operation was aborted by the system, usually
	// because of a concurrency issue such as a sequencer check failure or
	// transaction abort.
	ABORTED  = 10;

	// OutOfRange indicates that the operation was attempted past the valid
	// range (for example, seeking past end-of-file).
	OUT_OF_RANGE = 11;

	// Unimplemented indicates that the operation isn't implemented,
	// supported, or enabled in this service.
	UNIMPLEMENTED = 12;

	// Internal indicates that some invariants expected by the underlying
	// system have been broken. This code is reserved for serious errors.
	INTERNAL = 13;

	// Unavailable indicates that the service is currently unavailable. This
	// is usually temporary, so clients can back off and retry idempotent
	// operations.
	UNAVAILABLE = 14;

	// DataLoss indicates that the operation has resulted in unrecoverable
	// data loss or corruption.
	DATA_LOSS = 15;

	// Unauthenticated indicates that the request does not have valid
	// authentication credentials for the operation.
	UNAUTHENTICATED = 16;

    DEBUG_ERROR = 17;
    BAD_STREAM_ID = 18;
    BAD_STREAM_CREATION_PARAMS = 19;
    INTERNAL_ERROR_SWITCH = 20;
    BAD_EVENT_ID = 21;
    BAD_EVENT_SIGNATURE = 22;
    BAD_HASH_FORMAT = 23;
    BAD_PREV_EVENTS = 24;
    NO_EVENT_SPECIFIED = 25;
    BAD_EVENT = 26;
    USER_CANT_POST = 27;
    STREAM_BAD_HASHES = 28;
    STREAM_EMPTY = 29;
    STREAM_BAD_EVENT = 30;
    BAD_DELEGATE_SIG = 31;
    BAD_PUBLIC_KEY = 32;
    BAD_PAYLOAD = 33;
    BAD_HEX_STRING = 34;
    BAD_EVENT_HASH = 35;
    BAD_SYNC_COOKIE = 36;
    DUPLICATE_EVENT = 37;
    BAD_BLOCK = 38;
    STREAM_NO_INCEPTION_EVENT = 39;
    BAD_BLOCK_NUMBER = 40;
    BAD_MINIPOOL_SLOT = 41;
    BAD_CREATOR_ADDRESS = 42;
    STALE_DELEGATE = 43;
    BAD_LINK_WALLET_BAD_SIGNATURE = 44;
    BAD_ROOT_KEY_ID = 45;
    UNKNOWN_NODE = 46;
    DB_OPERATION_FAILURE = 47;
    MINIBLOCKS_STORAGE_FAILURE = 48;
    BAD_ADDRESS = 49;
    BUFFER_FULL = 50;
}
