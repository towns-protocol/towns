syntax = "proto3";
package casablancapayloads;
option go_package = "casablanca/payloads";


message ChannelMessage {
    message Reaction {
        string ref_event_id = 1;
        string reaction = 2;
    }

    message Edit {
        string ref_event_id = 1;
        Post post = 2;
    }

    message Redaction {
        string ref_event_id = 1;
        optional string reason = 2;
    }

    message Post {
        message Mention {
            string user_id = 1;
            string display_name = 2;
        }
        
        message Content {
            message Text {
                string body = 1;
                repeated Mention mentions = 2;
            }

            message Image {
                message Info {
                    string url = 1;
                    string mimetype = 2;
                    optional int32 size = 3;
                    optional int32 width = 4;
                    optional int32 height = 5;
                }
                string title = 1;
                Info info = 2;
                optional Info thumbnail = 3;
            }

            message GM {
                string type_url = 1;
                optional bytes value = 2;
            }
            
            message MediaInfo {
                string mimetype = 1;
                int64 sizeBytes = 2;
                int32 widthPixels = 3;
                int32 heightPixels = 4;   
            }
                         
            message EmbeddedMedia {
                MediaInfo info = 1;
                bytes content = 2;
            }

            message ChunkedMedia {

                message AESGCM {
                    bytes iv = 1;
                    bytes secretKey = 2;
                }

                MediaInfo info = 1;
                string streamId = 2;
                EmbeddedMedia thumbnail = 3;
                oneof encryption {
                    AESGCM aesgcm = 101;
                }
            }
        }
        
        optional string thread_id = 1;
        optional string thread_preview = 2;
    
        oneof content {
            Content.Text text = 101;
            Content.Image image = 102;
            Content.GM gm = 103;
            Content.EmbeddedMedia embeddedMedia = 104;
            Content.ChunkedMedia chunkedMedia = 105;
        }
    }
    
    oneof payload {
        Post post = 1;
        Reaction reaction = 2;
        Edit edit = 3;
        Redaction redaction = 4;
    }
}

message ChannelProperties {
    string name = 1;
    string topic = 2;
}

message UserMetadataProperties {
    optional string username = 1;
    optional string display_name = 2;
}

message FullyReadMarkers {
    message Content {
        string channel_id = 1;
        optional string thread_parent_id = 2;
        string event_id = 3; // id of the first unread event in the stream
        int64 event_num = 4; // event number of the first unread event in the stream
        int64 begin_unread_window = 5; // begining of the unread window, on marking as read, number is set to end+1
        int64 end_unread_window = 6; // latest event seen by the code
        bool is_unread = 7;
        int64 markedReadAtTs = 8; // timestamp when the event was marked as read
        int32 mentions = 9;
    }
    // map of ThreadId to Content
    map<string, Content> markers = 1;
}

// value field of a ToDeviceMessage, which is either
// a key response
message ToDeviceMessage {
    message KeyResponse {
        /** Stream ID that sessions belong to */
        string stream_id = 1;
        repeated MegolmSession sessions = 2;
        KeyResponseKind kind = 3;
    }

    reserved 1;
    oneof payload {
        KeyResponse response = 2;
    }
}

/** Olm encrypted messages are decoded into ToDeviceMessages.
*
*/
message OlmMessage {
        ToDeviceMessage content = 1;
}

/** Exported Megolm session data.
*/
message MegolmSession {
    /** Stream id associated with session */
    string stream_id = 1;
    /** Unique id for this session */
    string session_id = 2;
    /** Base64-encoded megolm session key data */
    string session_key = 3;
    optional string algorithm = 4;
}

enum KeyResponseKind {
    KRK_UNDEFINED = 0;
    KRK_KEYS_FOUND = 1;
    KRK_KEYS_NOT_FOUND = 2;
    KRK_CHANNEL_NOT_FOUND = 3;
}

/** 
* RiverKey is used to store private part of River Root Key (RK) or River Device Key (RDK), and (optionally) signature for RDK.
* The signature is always a ECDSA signature by RK of the public part of RDK.
**/ 
message RiverKey {
    bytes private_key = 1;
    bytes signature = 2;
}
