set shell := ["bash", "-eu", "-o", "pipefail", "-c"]
set export

RUN_ENV := env_var_or_default("RUN_ENV", "local_dev")
ENV_PATH_BASE := './env/local'
ENV_PATH := ENV_PATH_BASE / RUN_ENV
ENV_FILE := ENV_PATH / "env.env"
RUN_BASE := './run_files' / RUN_ENV
RIVER_ENV := RUN_ENV
CONTRACTS_DIR := '../packages/generated/deployments' / RUN_ENV
INSTANCE_BASE := RUN_BASE
RPC_BASE := 'http://127.0.0.1:8545'
RPC_RIVER := 'http://127.0.0.1:8546'

# Docker-related environment variables
USE_DOCKER_CHAINS := env_var_or_default("USE_DOCKER_CHAINS", "0")

OPERATOR_ADDRESS := `source ../packages/contracts/.env.localhost && echo "${SENDER_ADDRESS}"`
LOCAL_PRIVATE_KEY := `source ../packages/contracts/.env.localhost && echo "${LOCAL_PRIVATE_KEY}"`

# Set to "-x" to log bash commands
JUST_BASH_OPTS := env_var_or_default("JUST_BASH_OPTS", "")
BASH_OPTS := '-euo pipefail ' + JUST_BASH_OPTS

# NOTE: first command also runs when just is called without arguments

help:
    @just --list

print-env:
    @echo "RUN_ENV=${RUN_ENV}"
    @echo "ENV_PATH_BASE=${ENV_PATH_BASE}"
    @echo "ENV_PATH=${ENV_PATH}"
    @echo "ENV_FILE=${ENV_FILE}"
    @echo "RUN_BASE=${RUN_BASE}"
    @echo "CONTRACTS_DIR=${CONTRACTS_DIR}"
    @echo "INSTANCE_BASE=${INSTANCE_BASE}"
    @echo "RPC_BASE=${RPC_BASE}"
    @echo "RPC_RIVER=${RPC_RIVER}"
    @echo "OPERATOR_ADDRESS=${OPERATOR_ADDRESS}"
    @echo "LOCAL_PRIVATE_KEY=${LOCAL_PRIVATE_KEY}"

clean:
    @rm -rf ${RUN_BASE}

clear-logs: (_loop-instances "_clear_instance_logs")

_clear_instance_logs $INSTANCE_NUM $INSTANCE_DIR:
    @rm -rf $INSTANCE_DIR/logs/*

_get-docker-build-hash:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    # Hash multiple paths that affect the Docker build
    # IMPORTANT: This uses git tree hash, so uncommitted changes won't affect the hash.
    # You must commit changes to Docker-related files to get a new image built.
    {
        git ls-tree HEAD ../packages/anvil-docker 2>/dev/null
        git ls-tree HEAD ../packages/contracts/scripts 2>/dev/null
        git ls-tree HEAD ../packages/contracts/src 2>/dev/null
        git ls-tree HEAD ../scripts/deploy-contracts.sh 2>/dev/null
        git ls-tree HEAD ../scripts/deploy-base-contracts.sh 2>/dev/null
        git ls-tree HEAD ../scripts/start-local-basechain.sh 2>/dev/null
        git ls-tree HEAD ../scripts/start-local-riverchain.sh 2>/dev/null
        git ls-tree HEAD ../core/justfile 2>/dev/null
    } | sha256sum | cut -c1-12 2>/dev/null || echo "dev"

_check-remote-image IMAGE_TAG:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    docker manifest inspect {{IMAGE_TAG}} >/dev/null 2>&1

_get-docker-image:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    BUILD_HASH=$(just _get-docker-build-hash)
    LOCAL_IMAGE="towns-anvil:${BUILD_HASH}"
    REMOTE_IMAGE="public.ecr.aws/h5v6m2x1/towns-anvil:${BUILD_HASH}"

    # Check if image exists locally first (from CI artifact or previous build)
    if docker images -q "${LOCAL_IMAGE}" 2>/dev/null | grep -q .; then
        echo "Using image: ${LOCAL_IMAGE}" >&2
        echo "${LOCAL_IMAGE}"
        exit 0
    fi

    # Check remote ECR
    echo "Checking for remote image: ${REMOTE_IMAGE}" >&2
    if just _check-remote-image "${REMOTE_IMAGE}"; then
        echo "Found remote image with tag: ${BUILD_HASH}" >&2
        echo "${REMOTE_IMAGE}"
    else
        echo "Remote image not found for hash: ${BUILD_HASH}" >&2
        echo "Building local image: ${LOCAL_IMAGE}" >&2
        just build-anvil-docker "${BUILD_HASH}"
        echo "${LOCAL_IMAGE}"
    fi

# Build Docker image locally with specified tag
build-anvil-docker $TAG="local":
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    cd ../
    docker build -t towns-anvil:${TAG} -f ./packages/anvil-docker/Dockerfile .
    echo "Built local image: towns-anvil:${TAG}" >&2

_anvil-start $NAME $PORT $CHAIN_ID:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    mkdir -p ./run_files/anvil
    if nc -z localhost ${PORT} > /dev/null 2>&1; then
        echo "Anvil already running on port ${PORT}"
    else
        if [ "${USE_DOCKER_CHAINS}" = "1" ]; then
            echo "Starting Docker ${NAME} chain on port ${PORT}"
            IMAGE=$(just _get-docker-image)

            # Expose Alto bundler port (4337) for base chain
            ALTO_PORT_ARG=""
            if [ "${NAME}" = "base" ]; then
                ALTO_PORT_ARG="-p 4337:4337"
            fi

            docker run -d \
                --name towns-${NAME}-chain \
                -p ${PORT}:${PORT} \
                ${ALTO_PORT_ARG} \
                -e CHAIN=${NAME} \
                -e RIVER_BLOCK_TIME \
                $IMAGE

            ../scripts/wait-for-port.sh ${PORT} "Docker_anvil_${NAME}"

            # Wait for Alto bundler if base chain
            if [ "${NAME}" = "base" ]; then
                echo "Waiting for Alto bundler on port 4337..."
                ../scripts/wait-for-port.sh 4337 "Docker_alto"
            fi
        else
            echo "Starting ${NAME} on port ${PORT}"
            mkdir -p ./run_files/anvil
            nohup anvil --chain-id ${CHAIN_ID} \
                --port ${PORT} \
                --block-time 1 \
                --block-base-fee-per-gas 1 \
                --disable-block-gas-limit \
                --disable-code-size-limit \
                --disable-min-priority-fee \
                --max-persisted-states 50 \
                --gas-price 1 \
                > ./run_files/anvil/${NAME}.log 2>&1 &
            ../scripts/wait-for-port.sh ${PORT} anvil_${NAME}
        fi
    fi

# Alto bundler for ERC-4337 account abstraction
_alto-start:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    if nc -z localhost 4337 > /dev/null 2>&1; then
        echo "Alto bundler already running on port 4337"
    else
        echo "Starting Alto bundler on port 4337..."
        mkdir -p ./run_files/anvil
        ANVIL_PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"
        ENTRYPOINT_V06="0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789"
        ENTRYPOINT_V07="0x0000000071727De22E5E9d8BAf0edAc6f37da032"
        ( nohup bunx @pimlico/alto@0.0.20 \
            --entrypoints "${ENTRYPOINT_V06},${ENTRYPOINT_V07}" \
            --rpc-url "http://127.0.0.1:8545" \
            --executor-private-keys "${ANVIL_PRIVATE_KEY}" \
            --utility-private-key "${ANVIL_PRIVATE_KEY}" \
            --min-balance "0" \
            --safe-mode false \
            --deploy-simulations-contract \
            --port 4337 \
            </dev/null > ./run_files/anvil/alto.log 2>&1 & )
        ../scripts/wait-for-port.sh 4337 alto_bundler
    fi

_alto-stop:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    ../scripts/kill-on-port.sh 4337 alto_bundler

# Run Alto bundler in foreground (for VSCode task)
alto-run:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    if nc -z localhost 4337 > /dev/null 2>&1; then
        echo "Alto bundler already running on port 4337"
        exit 0
    fi
    echo "Starting Alto bundler on port 4337..."
    ANVIL_PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"
    ENTRYPOINT_V06="0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789"
    ENTRYPOINT_V07="0x0000000071727De22E5E9d8BAf0edAc6f37da032"
    bunx @pimlico/alto@0.0.20 \
        --entrypoints "${ENTRYPOINT_V06},${ENTRYPOINT_V07}" \
        --rpc-url "http://127.0.0.1:8545" \
        --executor-private-keys "${ANVIL_PRIVATE_KEY}" \
        --utility-private-key "${ANVIL_PRIVATE_KEY}" \
        --min-balance "0" \
        --safe-mode false \
        --deploy-simulations-contract \
        --port 4337

anvil-base:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    just _anvil-start "base" "8545" "31337"

# Start base anvil chain with Alto bundler (native mode - runs in foreground)
anvil-base-with-alto:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    just _anvil-start "base" "8545" "31337"
    echo "Waiting for EntryPoint contracts to be deployed..."
    # Wait for EntryPoint v0.7 to be deployed (happens during 'Configure Nodes' step)
    while ! cast code 0x0000000071727De22E5E9d8BAf0edAc6f37da032 --rpc-url http://127.0.0.1:8545 2>/dev/null | grep -q "^0x6080"; do
        sleep 1
    done
    echo "EntryPoint deployed. Starting Alto bundler..."
    just alto-run

anvil-base-stop:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    if [ "${USE_DOCKER_CHAINS}" = "1" ]; then
        docker stop towns-base-chain 2>/dev/null || true
        docker rm towns-base-chain 2>/dev/null || true
    else
        just _alto-stop
        ../scripts/kill-on-port.sh 8545 anvil_base
    fi

anvil-river: (_anvil-start "river" "8546" "31338")

anvil-river-stop:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    if [ "${USE_DOCKER_CHAINS}" = "1" ]; then
        docker stop towns-river-chain 2>/dev/null || true
        docker rm towns-river-chain 2>/dev/null || true
    else
        ../scripts/kill-on-port.sh 8546 anvil_river
    fi

anvils: anvil-base anvil-river

anvils-stop: anvil-base-stop anvil-river-stop

anvils-tail-logs:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    tail -n 10 -F ./run_files/anvil/*.log

storage-start:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    if nc -z localhost 5433 > /dev/null 2>&1; then
        echo "Postgres already running on port 5433"
    else
        echo "Starting Postgres"
        cd ./scripts
        docker compose --project-name river up --detach --wait
    fi

storage-stop:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    cd ./scripts
    docker compose --project-name river down

storage-clean:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    cd ./scripts
    docker compose --project-name river down --volumes --rmi all

just-deploy-contracts:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    echo "Deploying contracts"

    if [ "${USE_DOCKER_CHAINS}" = "1" ]; then
        # Copy entire local_dev structure from container
        echo "Extracting contracts and configs from Docker container"
        docker cp towns-base-chain:/app/local_dev/. ${CONTRACTS_DIR}/
    else
        echo "Deploying contracts"
        ../scripts/deploy-contracts.sh
    fi

deploy-contracts: anvils just-deploy-contracts create-contracts-env

# Create contracts.env file with extracted addresses
create-contracts-env:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    if [ -d "${CONTRACTS_DIR}" ]; then
        # Create contracts.env with extracted addresses
        mkdir -p ${RUN_BASE}
        echo "" > ${RUN_BASE}/contracts.env
        echo "RIVER_ARCHITECTCONTRACT_ADDRESS=$(jq -r '.address' ${CONTRACTS_DIR}/base/addresses/spaceFactory.json)" >> ${RUN_BASE}/contracts.env
        echo "RIVER_ENTITLEMENT_CONTRACT_ADDRESS=$(jq -r '.address' ${CONTRACTS_DIR}/base/addresses/baseRegistry.json)" >> ${RUN_BASE}/contracts.env
        echo "RIVER_REGISTRYCONTRACT_ADDRESS=$(jq -r '.address' ${CONTRACTS_DIR}/river/addresses/riverRegistry.json)" >> ${RUN_BASE}/contracts.env
        echo "RIVER_TEST_CONTRACT_ADDRESS=$(jq -r '.address' ${CONTRACTS_DIR}/base/addresses/utils/entitlementGatedExample.json)" >> ${RUN_BASE}/contracts.env
        echo "RIVER_APPREGISTRYCONTRACT_ADDRESS=$(jq -r '.address' ${CONTRACTS_DIR}/base/addresses/appRegistry.json)" >> ${RUN_BASE}/contracts.env
        # Generate a random test entitlements bypass secret and persist it for this run
        TEST_SECRET=$(openssl rand -hex 32)
        echo "RIVER_TESTENTITLEMENTSBYPASSSECRET=${TEST_SECRET}" >> ${RUN_BASE}/contracts.env
    else
        echo "ERROR: Contract directory not found: ${CONTRACTS_DIR}"
        echo "Contract deployment may have failed. Cannot create contracts.env."
        exit 1
    fi

_config-instance $INSTANCE_NUM $INSTANCE_DIR:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    mkdir -p ${INSTANCE_DIR}/{config,logs,wallet,certs}
    echo "RIVER_PORT=$((${RPC_PORT} + ${INSTANCE_NUM}))" > ${INSTANCE_DIR}/config/config.env

    if [ ! -f "${INSTANCE_DIR}/wallet/operator_private_key" ]; then
        cast wallet new --json > "${INSTANCE_DIR}/wallet/operator_wallet.json"
        jq -r '.[0].address' "${INSTANCE_DIR}/wallet/operator_wallet.json" > "${INSTANCE_DIR}/wallet/operator_address"
        jq -r '.[0].private_key' "${INSTANCE_DIR}/wallet/operator_wallet.json" | sed 's/^0x//' > "${INSTANCE_DIR}/wallet/operator_private_key"
    fi

    if [ ! -f "${INSTANCE_DIR}/wallet/private_key" ]; then
        cast wallet new --json > "${INSTANCE_DIR}/wallet/wallet.json"
        jq -r '.[0].address' "${INSTANCE_DIR}/wallet/wallet.json" > "${INSTANCE_DIR}/wallet/node_address"
        jq -r '.[0].private_key' "${INSTANCE_DIR}/wallet/wallet.json" | sed 's/^0x//' > "${INSTANCE_DIR}/wallet/private_key"
    fi

    if [ ! -f "${INSTANCE_DIR}/certs/cert.pem" ]; then
        ./scripts/generate-certs.sh $(realpath ${INSTANCE_DIR}/certs)
    fi

config-instances:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    set -a  # Enable automatic export of all variables
    source ${ENV_FILE}
    set +a  # Disable automatic export
    echo "Starting config-instances..."
    
    # Array to collect addresses for Multicall3
    RECIPIENTS=()
    
    # Sequential loop to create instances and collect addresses
    for ((i=0; i<${NUM_INSTANCES}; i++)); do
        INSTANCE_NAME=$(printf "%02d" ${i})
        INSTANCE_DIR="${INSTANCE_BASE}/${INSTANCE_NAME}"
        echo "Configuring instance ${i}..."
        
        # Use existing _config-instance function
        just _config-instance ${i} ${INSTANCE_DIR}
        
        # Collect addresses for Multicall3
        OPERATOR_ADDRESS=$(cat "${INSTANCE_DIR}/wallet/operator_address")
        NODE_ADDRESS=$(cat "${INSTANCE_DIR}/wallet/node_address")
        RECIPIENTS+=("$OPERATOR_ADDRESS" "$NODE_ADDRESS")
    done
    
    # Use Multicall3 to distribute ETH in batches
    MULTICALL3_ADDRESS="0xcA11bde05977b3631167028862bE2a173976CA11"
    VALUE="10000000000000000000"  # 10 ETH in wei
    
    echo "Distributing ETH using Multicall3..."
    
    # Build calls array
    CALLS=""
    for addr in "${RECIPIENTS[@]}"; do
        if [ -z "$CALLS" ]; then
            CALLS="(${addr},false,${VALUE},0x)"
        else
            CALLS="${CALLS},(${addr},false,${VALUE},0x)"
        fi
    done
    
    # Calculate total value needed (2 addresses per instance * 10 ETH each)
    TOTAL_VALUE_WEI=$(echo "${NUM_INSTANCES} * 2 * ${VALUE}" | bc)
    
    # Send to Base chain
    echo "Sending ETH to Base chain..."
    cast send \
        --confirmations 0 \
        --value "${TOTAL_VALUE_WEI}" \
        --private-key $LOCAL_PRIVATE_KEY \
        --rpc-url ${RPC_BASE} \
        $MULTICALL3_ADDRESS \
        "aggregate3Value((address,bool,uint256,bytes)[])" \
        "[${CALLS}]" > /dev/null &
    
    # Send to River chain
    echo "Sending ETH to River chain..."
    cast send \
        --confirmations 0 \
        --value "${TOTAL_VALUE_WEI}" \
        --private-key $LOCAL_PRIVATE_KEY \
        --rpc-url ${RPC_RIVER} \
        $MULTICALL3_ADDRESS \
        "aggregate3Value((address,bool,uint256,bytes)[])" \
        "[${CALLS}]" > /dev/null &
    
    # Wait for both transactions to complete
    wait

config-app-registry:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    INSTANCE_DIR="${INSTANCE_BASE}/app-registry"
    mkdir -p ${INSTANCE_DIR}/{config,logs,certs}
    # Take the next available port after all stream nodes have been assigned.
    echo "RIVER_PORT=$((${APP_REGISTRY_PORT}))" > ${INSTANCE_DIR}/config/config.env
    if [ ! -f "${INSTANCE_DIR}/certs/cert.pem" ]; then
    ./scripts/generate-certs.sh $(realpath ${INSTANCE_DIR}/certs)
    fi

config-notifications:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    INSTANCE_DIR="${INSTANCE_BASE}/notifications"
    mkdir -p ${INSTANCE_DIR}/{config,logs,certs}
    echo "RIVER_PORT=$((${NOTIFICATION_SERVICE_PORT}))" > ${INSTANCE_DIR}/config/config.env
    if [ ! -f "${INSTANCE_DIR}/certs/cert.pem" ]; then
    ./scripts/generate-certs.sh $(realpath ${INSTANCE_DIR}/certs)
    fi

_remove-instance $INSTANCE_NUM $INSTANCE_DIR:
    @rm -rf ${INSTANCE_DIR}

remove-instances: (_loop-instances "_remove-instance")

config-base-chain: deploy-contracts

# Run build node binary for environment
[positional-arguments]
run-bin *args:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    cd ${RUN_BASE}
    mkdir -p logs
    RIVER_PORT=80 ./bin/river_node \
        --config common.yaml \
        --config config.yaml \
        --config contracts.env \
        "$@"

# Run node from source with go run (for debugging)
[positional-arguments]
run-go *args:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    cd ${RUN_BASE}
    mkdir -p logs
    go run ../../river_node/main.go \
        --config common.yaml \
        --config config.yaml \
        --config contracts.env \
        "$@"

# Run node from source with go run with config for instance N
[positional-arguments]
_run-go-inst $INSTANCE_NUM $INSTANCE_DIR *args:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    cd ${INSTANCE_DIR}
    mkdir -p logs
    shift 2
    go run ../../../river_node/main.go \
        --config ../common.yaml \
        --config ../config.yaml \
        --config ../contracts.env \
        --config config/config.env \
        "$@"

# Run node from source with go run with config for instance N
[positional-arguments]
run-go-inst $INSTANCE_NUM *args:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    INSTANCE_NAME=$(printf "%02d" ${INSTANCE_NUM})
    INSTANCE_DIR="${INSTANCE_BASE}/${INSTANCE_NAME}"
    shift
    just _run-go-inst ${INSTANCE_NUM} ${INSTANCE_DIR} "$@"

# Run node from source with go run with for each instance
[positional-arguments]
run-go-all *args:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    just _loop-instances-seq-args _run-go-inst "$@"

just-config-river-chain:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    PRIVATE_KEY=${LOCAL_PRIVATE_KEY} \
        just run-bin \
        on-chain-config set-csv ../../${ENV_PATH}/on_chain.csv

config-river-chain: deploy-contracts config-root build just-config-river-chain

config-root:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    mkdir -p ${RUN_BASE}
    cp ${ENV_PATH_BASE}/common/common.yaml ${RUN_BASE}/common.yaml
    cp ${ENV_PATH_BASE}/common/run.sh ${RUN_BASE}/run.sh
    cp ${ENV_PATH}/config.yaml ${RUN_BASE}/config.yaml

_register-node-base $INSTANCE_NUM $INSTANCE_DIR:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    if [ "${DISABLE_BASE_CHAIN}" != "true" ]; then
        NODE_ADDRESS=$(cat ${INSTANCE_DIR}/wallet/node_address)
        NONCE=$((BASE_REGISTRATION_NONCE + INSTANCE_NUM))
        
        echo "Registering instance ${INSTANCE_NUM} with nonce ${NONCE}"
        cast send \
            --confirmations 0 \
            --nonce ${NONCE} \
            --gas-limit 200000 \
            --gas-price 1gwei \
            --rpc-url ${RPC_BASE} \
            --private-key $LOCAL_PRIVATE_KEY \
            $RIVER_ENTITLEMENT_CONTRACT_ADDRESS \
            "registerNode(address)" \
            $NODE_ADDRESS > /dev/null
    fi

# get the contract addresses from the node registry contract deployed to river chain
get_all_node_addresses:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    source ${RUN_BASE}/contracts.env
    cast call \
            --rpc-url ${RPC_RIVER} \
            $RIVER_REGISTRYCONTRACT_ADDRESS \
            "getAllNodeAddresses()"

just-register-nodes-base:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    if [ "${DISABLE_BASE_CHAIN}" != "true" ]; then
        set -a  # Enable auto-export
        source ${RUN_BASE}/contracts.env
        set +a  # Disable auto-export
        
        # Get initial nonce for LOCAL_PRIVATE_KEY
        LOCAL_ADDRESS=$(cast wallet address $LOCAL_PRIVATE_KEY)
        export BASE_REGISTRATION_NONCE=$(cast nonce --rpc-url ${RPC_BASE} $LOCAL_ADDRESS)

        # Use parallel helper to run all registrations
        echo "Starting parallel Base chain registration with initial nonce ${BASE_REGISTRATION_NONCE}"
        just _parallel-just "_register-node-base"
        
        echo "All Base chain registrations launched"
    fi

register-nodes-base: config-base-chain config-instances just-register-nodes-base

_approve-operator-river $INSTANCE_NUM $INSTANCE_DIR:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    OPERATOR_ADDRESS=$(cat ${INSTANCE_DIR}/wallet/operator_address)
    NONCE=$((RIVER_APPROVE_NONCE + INSTANCE_NUM))
    
    echo "Approving operator for instance ${INSTANCE_NUM} with nonce ${NONCE}"
    cast send \
        --confirmations 0 \
        --nonce ${NONCE} \
        --gas-limit 200000 \
        --gas-price 1gwei \
        --rpc-url ${RPC_RIVER} \
        --private-key $LOCAL_PRIVATE_KEY \
        $RIVER_REGISTRYCONTRACT_ADDRESS \
        "approveOperator(address)" \
        $OPERATOR_ADDRESS > /dev/null

_register-node-river $INSTANCE_NUM $INSTANCE_DIR:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    NODE_ADDRESS=$(cat ${INSTANCE_DIR}/wallet/node_address)
    OPERATOR_KEY=$(cat ${INSTANCE_DIR}/wallet/operator_private_key)
    source ${INSTANCE_DIR}/config/config.env
    
    echo "Registering node for instance ${INSTANCE_NUM} (operator nonce: 0)"
    cast send \
        --confirmations 0 \
        --nonce 0 \
        --gas-limit 300000 \
        --gas-price 1gwei \
        --rpc-url ${RPC_RIVER} \
        --private-key $OPERATOR_KEY \
        $RIVER_REGISTRYCONTRACT_ADDRESS \
        "registerNode(address,string,uint8)" \
        $NODE_ADDRESS \
        https://localhost:${RIVER_PORT} \
        2 > /dev/null

just-register-nodes-river:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    set -a  # Enable auto-export
    source ${RUN_BASE}/contracts.env
    set +a  # Disable auto-export
    
    # Get initial nonce for LOCAL_PRIVATE_KEY
    LOCAL_ADDRESS=$(cast wallet address $LOCAL_PRIVATE_KEY)
    export RIVER_APPROVE_NONCE=$(cast nonce --rpc-url ${RPC_RIVER} $LOCAL_ADDRESS)
    
    echo "Starting parallel River chain registration with LOCAL_PRIVATE_KEY nonce ${RIVER_APPROVE_NONCE}"

    # Phase 1: Run all approveOperator transactions in parallel
    echo "Phase 1: Running all approveOperator transactions..."
    just _parallel-just "_approve-operator-river"
    echo "All operators approved"

    # Phase 2: Run all registerNode transactions in parallel
    echo "Phase 2: Running all registerNode transactions..."
    just _parallel-just "_register-node-river"
    
    echo "All nodes registered"

register-nodes-river: config-river-chain config-instances just-register-nodes-river

config: config-root config-app-registry config-notifications register-nodes-base register-nodes-river storage-start _alto-start

build:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    OUTPUT=${RUN_BASE}/bin/river_node
    echo "Building node binary ${OUTPUT}"
    mkdir -p ${RUN_BASE}/bin

    go build \
        -o ${OUTPUT} \
        -race \
        -ldflags="-X github.com/towns-protocol/towns/core/river_node/version.branch=$(git rev-parse --abbrev-ref HEAD) -X github.com/towns-protocol/towns/core/river_node/version.commit=$(git describe --tags --always --dirty)" \
        ./river_node/main.go

_run-node $INSTANCE_NUM $INSTANCE_DIR:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    RUN_ARGS=${RUN_ARGS:-}
    RUN_CMD=${RUN_CMD:-run}
    if [ "${DISABLE_BASE_CHAIN}" == "true" ]; then
        RUN_CMD="run stream"
    fi
    cd ${INSTANCE_DIR}
    ../bin/river_node ${RUN_CMD} \
        --config ../common.yaml \
        --config ../contracts.env \
        --config ../config.yaml \
        --config config/config.env \
        ${RUN_ARGS} \
        > ./logs/tty.stdout.log 2> ./logs/tty.stderr.log &

start-app-registry:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    echo "Running start-app-registry with args $@"
    source ${ENV_FILE}
    RUN_ARGS=${RUN_ARGS:-}
    RUN_CMD=${RUN_CMD:-app-registry}
    cd ${INSTANCE_BASE}/app-registry
    ../bin/river_node ${RUN_CMD} \
        --config ../common.yaml \
        --config ../contracts.env \
        --config ../config.yaml \
        --config config/config.env \
        ${RUN_ARGS} \
        > ./logs/tty.stdout.log 2> ./logs/tty.stderr.log &

start-notifications:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    echo "Running start-notifications with args $@"
    source ${ENV_FILE}
    RUN_ARGS=${RUN_ARGS:-}
    RUN_CMD=${RUN_CMD:-notifications}
    cd ${INSTANCE_BASE}/notifications
    ../bin/river_node ${RUN_CMD} \
        --config ../common.yaml \
        --config ../contracts.env \
        --config ../config.yaml \
        --config config/config.env \
        ${RUN_ARGS} \
        > ./logs/tty.stdout.log 2> ./logs/tty.stderr.log &

_stop-node $INSTANCE_NUM $INSTANCE_DIR:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    if [ ! -f "${INSTANCE_DIR}/config/config.env" ]; then
        exit 0
    fi
    source ${INSTANCE_DIR}/config/config.env
    ../scripts/kill-on-port.sh ${RIVER_PORT} instance_${INSTANCE_NUM}

stop-app-registry:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    echo "Running stop-app-registry with args $@"
    source ${ENV_FILE}
    if [ ! -f "${INSTANCE_BASE}/app-registry/config/config.env" ]; then
        exit 0
    fi
    source ${INSTANCE_BASE}/app-registry/config/config.env
    ../scripts/kill-on-port.sh ${RIVER_PORT} app-registry

stop-notifications:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    echo "Running stop-notifications with args $@"
    source ${ENV_FILE}
    if [ ! -f "${INSTANCE_BASE}/notifications/config/config.env" ]; then
        exit 0
    fi
    source ${INSTANCE_BASE}/notifications/config/config.env
    ../scripts/kill-on-port.sh ${RIVER_PORT} notifications

# Stop all nodes
stop: (_loop-instances "_stop-node")

_wait-node $INSTANCE_NUM $INSTANCE_DIR:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    source ${INSTANCE_DIR}/config/config.env
    cd ..
    bunx wait-on https://localhost:${RIVER_PORT}/status?blockchain=1 --timeout=300000

wait-app-registry:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    echo "Running wait-app-registry with args $@"
    source ${ENV_FILE}
    source ${INSTANCE_BASE}/app-registry/config/config.env
    cd ..
    bunx wait-on https://localhost:${RIVER_PORT}/status?blockchain=0 --timeout=300000

wait-notifications:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    echo "Running wait-notifications with args $@"
    source ${ENV_FILE}
    source ${INSTANCE_BASE}/notifications/config/config.env
    cd ..
    bunx wait-on https://localhost:${RIVER_PORT}/status?blockchain=0 --timeout=300000

_wait-ctrl-c:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    echo "CTRL+C TO EXIT"
    bash -c 'trap "exit 0" INT TERM; while true; do sleep 1; done'

# Tail logs from all instances starting with 500 last lines
tail-logs:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    shopt -s nullglob
    LOGS=(${INSTANCE_BASE}/*/logs/tty.*.log)
    tail -n 500 -F ${LOGS[@]} | bunx pino-pretty

tail-app-registry-logs:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    shopt -s nullglob
    LOGS=(${INSTANCE_BASE}/app-registry/logs/tty.*.log)
    tail -n 500 -F ${LOGS[@]} | bunx pino-pretty

tail-notifications-logs:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    shopt -s nullglob
    LOGS=(${INSTANCE_BASE}/notifications/logs/tty.*.log)
    tail -n 500 -F ${LOGS[@]} | bunx pino-pretty

# Tail logs from all instances starting with 10 last lines
tail-logs-short:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    shopt -s nullglob
    LOGS=(${INSTANCE_BASE}/*/logs/tty.*.log)
    tail -n 10 -F ${LOGS[@]} | bunx pino-pretty

# Tail new logs from all instances
tail-logs-new:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    shopt -s nullglob
    LOGS=(${INSTANCE_BASE}/*/logs/tty.*.log)
    tail -n 0 -F ${LOGS[@]} | bunx pino-pretty

# Print last 10 lines from each instance log
print-logs:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    shopt -s nullglob
    LOGS=(${INSTANCE_BASE}/*/logs/tty.*.log)
    tail -n 10 ${LOGS[@]} | bunx pino-pretty

# Tail stderr from all instances
tail-stderr:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    shopt -s nullglob
    LOGS=(${INSTANCE_BASE}/*/logs/tty.stderr.log)
    tail -n 500 -F ${LOGS[@]} | bunx pino-pretty

# Print stderr from all instances
print-stderr:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    shopt -s nullglob
    LOGS=(${INSTANCE_BASE}/*/logs/tty.stderr.log)
    tail -n 10000 ${LOGS[@]} | bunx pino-pretty

# Exits with error if any instance has non-empty stderr
check-stderr:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    shopt -s nullglob
    LOGS=(${INSTANCE_BASE}/*/logs/tty.stderr.log)
    RESULT=$(tail -q ${LOGS[@]})
    if [ -n "${RESULT}" ]; then
        tail -n 10000 ${LOGS[@]} | bunx pino-pretty
        echo "ERROR: Found non-empty stderr logs"
        exit 1
    fi

_start-all: (_loop-instances "_run-node")

_wait-all: (_loop-instances "_wait-node")

# Config, build, and start nodes in background. Alias: cbs
config-and-start: stop config build start

alias cbs := config-and-start

# Start nodes in background, config and build should be run before
start: _start-all _wait-all

# Config, build, and run nodes in foreground, CTRL-C to exit
config-and-run: stop config build run

# Config, build, and run nodes in foreground tailing logs
config-run-tail: stop config build run-and-tail

# Run nodes in foreground, config and build should be run before, CTRL-C to exit
run: _start-all _wait-all _wait-ctrl-c stop

run-app-registry: start-app-registry wait-app-registry _wait-ctrl-c stop-app-registry

start-and-wait-app-registry: start-app-registry wait-app-registry

run-app-registry-and-tail: start-app-registry wait-app-registry tail-app-registry-logs stop-app-registry

run-notifications: start-notifications wait-notifications _wait-ctrl-c stop-notifications

start-and-wait-notifications: start-notifications wait-notifications

run-notifications-and-tail: start-notifications wait-notifications tail-notifications-logs stop-notifications

# Start nodes in foreground tailing logs, config and build should be run before
run-and-tail: _start-all _wait-all tail-logs stop

# Stop, build, and start nodes in background
restart: stop build start

# Simple parallel loop helper for just recipes
_parallel-just $CMD:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    set -a  # Enable automatic export of all variables
    source ${ENV_FILE}
    set +a  # Disable automatic export
    echo "Starting parallel ${CMD}..."
    for ((i=0; i<${NUM_INSTANCES}; i++)); do
        INSTANCE_NAME=$(printf "%02d" ${i})
        INSTANCE_DIR="${INSTANCE_BASE}/${INSTANCE_NAME}"
        just ${CMD} ${i} ${INSTANCE_DIR} &
    done
    
    echo "Waiting for all ${CMD} to complete..."
    wait
    echo "All ${CMD} completed"

_loop-instances-seq $CMD:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    for ((i=0; i<${NUM_INSTANCES}; i++)); do
        INSTANCE_NAME=$(printf "%02d" ${i})
        INSTANCE_DIR="${INSTANCE_BASE}/${INSTANCE_NAME}"
        echo "Running ${CMD} for instance ${i}"
        just ${CMD} ${i} ${INSTANCE_DIR}
    done

[positional-arguments]
_loop-instances-seq-args $CMD *args:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    shift
    source ${ENV_FILE}
    for ((i=0; i<${NUM_INSTANCES}; i++)); do
        INSTANCE_NAME=$(printf "%02d" ${i})
        INSTANCE_DIR="${INSTANCE_BASE}/${INSTANCE_NAME}"
        echo "Running ${CMD} for instance ${i} with args $@"
        just ${CMD} ${i} ${INSTANCE_DIR} "$@"
    done

# Loop instances without stopping on error, return 0 if all succeeded, 1 if any failed
_loop-instances-seq-nostop $CMD:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    EXIT_CODE=0
    for ((i=0; i<${NUM_INSTANCES}; i++)); do
        INSTANCE_NAME=$(printf "%02d" ${i})
        INSTANCE_DIR="${INSTANCE_BASE}/${INSTANCE_NAME}"
        echo "Running ${CMD} for instance ${i}"
        just ${CMD} ${i} ${INSTANCE_DIR} || EXIT_CODE=1
    done
    exit ${EXIT_CODE}

_loop-instances-parallel $CMD:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    seq 0 $((${NUM_INSTANCES}-1)) | parallel -j0 --line-buffer \
        'INSTANCE_NAME=$(printf "%02d" {})
         INSTANCE_DIR="${INSTANCE_BASE}/${INSTANCE_NAME}"
         just ${CMD} {} ${INSTANCE_DIR}'

# _loop-instances $CMD:
#     #!/usr/bin/env -S bash {{BASH_OPTS}}
#     if command -v parallel &> /dev/null; then
#         just _loop-instances-parallel "${CMD}"
#     else
#         just _loop-instances-seq "${CMD}"
#     fi

_loop-instances CMD: (_loop-instances-seq CMD)

_ping-anvil $URL $NAME:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    echo "PINGING ${NAME} ON ${URL}"
    cast chain-id -r ${URL}

ping-anvil-base: (_ping-anvil RPC_BASE "base")

ping-anvil-river: (_ping-anvil RPC_RIVER "river")

ping-anvils: ping-anvil-base ping-anvil-river

_ping-instance-tcp $INSTANCE_NUM $INSTANCE_DIR:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    source ${ENV_FILE}
    source ${INSTANCE_DIR}/config/config.env
    if ! (nc -z localhost ${RIVER_PORT} > /dev/null 2>&1); then
        echo "No instance ${INSTANCE_NUM} on port ${RIVER_PORT}"
        exit 1
    fi

ping-instances-tcp: (_loop-instances-seq-nostop "_ping-instance-tcp")

# Invoke cast with -r for river chain.
[positional-arguments]
cast-river +args:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    METHOD=$1
    shift
    cast ${METHOD} -r ${RPC_RIVER} "$@"

# Invoke cast with -r for base chain.
[positional-arguments]
cast-base *args:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    METHOD=$1
    shift
    cast ${METHOD} -r ${RPC_BASE} "$@"

_test-from-dir $DIR *args:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    cd $DIR
    echo "Running go test from $(git rev-parse --show-prefix)"
    if [[ "${GITHUB_ACTIONS:-false}" == "true" ]]; then
        go test {{args}}
    else
        go test {{args}} | bunx pino-pretty
    fi

_test-print-report-from-dir $DIR *args:
    #!/usr/bin/env -S bash {{BASH_OPTS}}
    cd $DIR
    echo "Running go test from $(git rev-parse --show-prefix)"
    if ! command -v gotestsum >/dev/null 2>&1; then
        go install gotest.tools/gotestsum@latest
    fi
    gotestsum --hide-summary=skipped {{args}}

# Run go tests from current directory
test *args: (_test-from-dir invocation_directory() args)

# Run all go tests from module root
test-all *args: (_test-from-dir justfile_directory() "-v" args "./...")

# Run all go tests from module root and print a report at the end
test-all-report *args: (_test-print-report-from-dir justfile_directory() args "./...")

# Run all go tests from current directory
t *args: (_test-from-dir invocation_directory() "-v" args "./...")

# Run go tests with info logging and test printing from current directory
[positional-arguments]
t-debug *args:
    RIVER_TEST_LOG=info RIVER_TEST_PRINT=1 just _test-from-dir {{invocation_directory()}} -v -count 1 "$@" ./...

# Run go tests with debug logging and test printing from current directory
[positional-arguments]
t-debug-debug *args:
    RIVER_TEST_LOG=debug RIVER_TEST_PRINT=1 just _test-from-dir {{invocation_directory()}} -v -count 1 "$@" ./...
