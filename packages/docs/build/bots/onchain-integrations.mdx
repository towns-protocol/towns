---
title: Onchain Integrations
---

Towns bots are onchain apps with two blockchain capabilities: direct contract interactions using your bot's wallet, and requesting users to sign transactions or messages.

## Bot Wallet Architecture

Your bot has two addresses:
- **Gas wallet** (`bot.viem.account`) - Signs and pays for transactions
- **App address** (`bot.appAddress`) - Treasury wallet (SimpleAccount)

<Note>
Your gas wallet needs Base ETH for transaction fees. See [Getting Started](/build/bots/getting-started#understanding-your-bots-wallet-architecture) for details.
</Note>

## Configuration

### Base RPC URL

For reliable blockchain interactions, configure a custom RPC endpoint. The default public RPC has strict rate limits.

```typescript
const bot = await makeTownsBot(
  process.env.APP_PRIVATE_DATA!,
  process.env.JWT_SECRET!,
  {
    baseRpcUrl: process.env.BASE_RPC_URL,
    commands
  }
)
```

Add to `.env`:

```bash
BASE_RPC_URL=https://base-mainnet.g.alchemy.com/v2/YOUR_API_KEY
```

We recommend getting a RPC URL from a reputable provider, like [Alchemy](https://www.alchemy.com/).

## Bot Contract Interactions

### Reading from Contracts

Read contract state without gas costs:

```ts
import { readContract } from 'viem/actions'
import simpleAppAbi from '@towns-protocol/bot/simpleAppAbi'

const owner = await readContract(bot.viem, {
  address: bot.appAddress,
  abi: simpleAppAbi,
  functionName: 'moduleOwner',
  args: []
})
```

### Writing to Contracts

Use `execute` from ERC-7821 for any onchain interaction:

```ts
import { execute } from 'viem/experimental/erc7821'
import { parseEther } from 'viem'
import { waitForTransactionReceipt } from 'viem/actions'

const hash = await execute(bot.viem, {
  address: bot.appAddress,
  account: bot.viem.account,
  calls: [{
    to: tokenAddress,
    abi: erc20Abi,
    functionName: 'transfer',
    args: [recipientAddress, parseEther('1.0')]
  }]
})

await waitForTransactionReceipt(bot.viem, { hash })
```

### Batch Transactions

Execute multiple operations atomically:

```ts
const hash = await execute(bot.viem, {
  address: bot.appAddress,
  account: bot.viem.account,
  calls: [
    {
      to: tokenAddress,
      abi: erc20Abi,
      functionName: 'approve',
      args: [dexAddress, amount]
    },
    {
      to: dexAddress,
      abi: dexAbi,
      functionName: 'swap',
      args: [tokenIn, tokenOut, amount]
    }
  ]
})
```

All operations succeed or all fail.

## User Interactions

Request users to sign transactions or messages from their wallets.

### Transaction Requests

Prompt users to execute transactions:

```ts
import { hexToBytes, encodeFunctionData } from 'viem'

bot.onSlashCommand('send-usdc', async (handler, event) => {
  const usdcAddress = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' // Base USDC
  const recipient = '0x1234567890123456789012345678901234567890'
  const amount = '50000000' // 50 USDC (6 decimals)
  
  // Encode ERC20 transfer
  const data = encodeFunctionData({
    abi: [{
      name: 'transfer',
      type: 'function',
      inputs: [
        { name: 'to', type: 'address' },
        { name: 'amount', type: 'uint256' }
      ]
    }],
    functionName: 'transfer',
    args: [recipient, BigInt(amount)]
  })
  
  await handler.sendInteractionRequest(
    event.channelId,
    {
      case: 'transaction',
      value: {
        id: 'usdc-transfer',
        title: 'Send USDC',
        subtitle: 'Send 50 USDC',
        content: {
          case: 'evm',
          value: {
            chainId: '8453',
            to: usdcAddress,
            value: '0',
            data: data,
            signerWallet: undefined // User chooses wallet
          }
        }
      }
    },
    hexToBytes(event.userId as `0x${string}`) // Optional: target specific user
  )
})
```

### Signature Requests

Request cryptographic signatures for authentication or permissions:

```ts
import { InteractionRequestPayload_Signature_SignatureType } from '@towns-protocol/proto'

bot.onSlashCommand('sign', async (handler, event) => {
  const typedData = {
    domain: {
      name: 'My Towns Bot',
      version: '1',
      chainId: 8453,
      verifyingContract: '0x0000000000000000000000000000000000000000'
    },
    types: {
      Message: [
        { name: 'from', type: 'address' },
        { name: 'content', type: 'string' },
        { name: 'timestamp', type: 'uint256' }
      ]
    },
    primaryType: 'Message',
    message: {
      from: event.userId,
      content: 'I agree to the terms',
      timestamp: Math.floor(Date.now() / 1000)
    }
  }
  
  await handler.sendInteractionRequest(
    event.channelId,
    {
      case: 'signature',
      value: {
        id: 'agreement-signature',
        title: 'Sign Agreement',
        subtitle: `Sign: "${typedData.message.content}"`,
        chainId: '8453',
        data: JSON.stringify(typedData),
        type: InteractionRequestPayload_Signature_SignatureType.TYPED_DATA,
        signerWallet: undefined
      }
    },
    hexToBytes(event.userId as `0x${string}`)
  )
})
```

### Handling Responses

Match responses to original requests using the request ID:

```ts
bot.onInteractionResponse(async (handler, event) => {
  const { response } = event
  
  switch (response.payload.content?.case) {
    case 'transaction':
      const txData = response.payload.content.value
      
      // Match response to original request
      if (txData.requestId === 'usdc-transfer') {
        if (txData.txHash) {
          await handler.sendMessage(
            event.channelId,
            `USDC transfer confirmed: ${txData.txHash}`
          )
        } else if (txData.error) {
          await handler.sendMessage(
            event.channelId,
            `USDC transfer failed: ${txData.error}`
          )
        }
      }
      break
      
    case 'signature':
      const signatureData = response.payload.content.value
      
      // Match response to original request
      if (signatureData.requestId === 'agreement-signature') {
        if (signatureData.signature) {
          // Verify and process signature
          await handler.sendMessage(
            event.channelId,
            `Agreement signed successfully`
          )
        } else if (signatureData.error) {
          await handler.sendMessage(
            event.channelId,
            `Signature failed: ${signatureData.error}`
          )
        }
      }
      break
  }
})
```

## Reference

### Transaction Parameters

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique identifier for matching responses |
| `title` | string | Transaction title shown to user |
| `subtitle` | string | Additional context |
| `chainId` | string | Chain ID (e.g., `'8453'` for Base mainnet) |
| `to` | address | Contract address |
| `value` | string | ETH value in wei |
| `data` | hex | Encoded function call |
| `signerWallet` | address? | Restrict to specific wallet (optional) |

### Signature Types

| Type | Description |
|------|-------------|
| `TYPED_DATA` | EIP-712 structured data (recommended) |
| `PERSONAL_SIGN` | Plain text message signature |

## Utility Functions

### getSmartAccountFromUserId

Get a user's smart account address:

```ts
import { getSmartAccountFromUserId } from '@towns-protocol/bot'

const wallet = await getSmartAccountFromUserId(bot, {
  userId: event.userId
})

if (wallet) {
  // Send tokens, check balances, etc.
}
```

Returns `null` if no smart account exists.

**Use cases:**
- Send tokens/NFTs to users
- Airdrop rewards
- Check balances
- Verify ownership

## Method Selection Guide

| Task | Method | Learn More |
|------|--------|------------|
| Read contract state | `readContract` | - |
| Bot sends transaction | `execute` | - |
| Bot sends batch transactions | `execute` with multiple calls | - |
| User sends transaction | `sendInteractionRequest` (transaction) | - |
| User signs message | `sendInteractionRequest` (signature) | - |
| User clicks button/form | `sendInteractionRequest` (form) | [Interactive Messages](/build/bots/interactive-messages) |
| Bot's SimpleAccount operations | `writeContract` | - |

## Best Practices

### Error Handling

Always check for errors in responses:

```ts
if (response.txHash) {
  // Success
} else if (response.error) {
  // Handle error
  await handler.sendMessage(channelId, `Error: ${response.error}`)
}
```

### Targeting Users

Target specific users for personal interactions:

```ts
await handler.sendInteractionRequest(
  channelId,
  payload,
  hexToBytes(userId as `0x${string}`) // Only this user can interact
)
```

Leave `undefined` for public interactions.

### Unique IDs

Use unique IDs for each interaction to match responses:

```ts
const id = `vote-${Date.now()}-${event.userId}`
```

### Gas Optimization

Batch multiple operations when possible:

```ts
// Good: One transaction
await execute(bot.viem, {
  calls: [approve(), swap(), stake()]
})

// Bad: Three transactions
await execute(bot.viem, { calls: [approve()] })
await execute(bot.viem, { calls: [swap()] })
await execute(bot.viem, { calls: [stake()] })
```

## Next Steps

- Create [interactive messages](/build/bots/interactive-messages) with buttons and forms
- Integrate [external services](/build/bots/external-interactions) via webhooks
- Learn about [slash commands](/build/bots/slash-commands)
- Explore [event handlers](/build/bots/events)

