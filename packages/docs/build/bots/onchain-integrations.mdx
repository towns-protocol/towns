---
title: Onchain Integrations
---

Towns bots are onchain apps with two blockchain capabilities: direct contract interactions using your bot's wallet, and requesting users to sign transactions or messages.

## Bot Wallet Architecture

Your bot has two addresses:
- **Gas wallet** (`bot.viem.account`) - Signs and pays for transactions
- **App address** (`bot.appAddress`) - Treasury wallet (SimpleAccount)

<Note>
Your gas wallet needs Base ETH for transaction fees. See [Getting Started](/build/bots/getting-started#understanding-your-bots-wallet-architecture) for details.
</Note>

## Configuration

### Base RPC URL

For reliable blockchain interactions, configure a custom RPC endpoint. The default public RPC has strict rate limits.

```typescript
const bot = await makeTownsBot(
  process.env.APP_PRIVATE_DATA!,
  process.env.JWT_SECRET!,
  {
    baseRpcUrl: process.env.BASE_RPC_URL,
    commands
  }
)
```

Add to `.env`:

```bash
BASE_RPC_URL=https://base-mainnet.g.alchemy.com/v2/YOUR_API_KEY
```

We recommend getting a RPC URL from a reputable provider, like [Alchemy](https://www.alchemy.com/).

## Bot Contract Interactions

### Reading from Contracts

Read contract state without gas costs:

```ts
import { readContract } from 'viem/actions'
import simpleAppAbi from '@towns-protocol/bot/simpleAppAbi'

const owner = await readContract(bot.viem, {
  address: bot.appAddress,
  abi: simpleAppAbi,
  functionName: 'moduleOwner',
  args: []
})
```

### Writing to Contracts

Use `execute` from ERC-7821 for any onchain interaction:

```ts
import { execute } from 'viem/experimental/erc7821'
import { parseEther } from 'viem'
import { waitForTransactionReceipt } from 'viem/actions'

const hash = await execute(bot.viem, {
  address: bot.appAddress,
  account: bot.viem.account,
  calls: [{
    to: tokenAddress,
    abi: erc20Abi,
    functionName: 'transfer',
    args: [recipientAddress, parseEther('1.0')]
  }]
})

await waitForTransactionReceipt(bot.viem, { hash })
```

### Batch Transactions

Execute multiple operations atomically:

```ts
const hash = await execute(bot.viem, {
  address: bot.appAddress,
  account: bot.viem.account,
  calls: [
    {
      to: tokenAddress,
      abi: erc20Abi,
      functionName: 'approve',
      args: [dexAddress, amount]
    },
    {
      to: dexAddress,
      abi: dexAbi,
      functionName: 'swap',
      args: [tokenIn, tokenOut, amount]
    }
  ]
})
```

All operations succeed or all fail.

<Note>
To request users to sign transactions or messages, see [Interactions](/build/bots/interactions). This page focuses on bot-initiated blockchain operations.
</Note>

## Reference

### Transaction Parameters

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique identifier for matching responses |
| `title` | string | Transaction title shown to user |
| `subtitle` | string | Additional context |
| `chainId` | string | Chain ID (e.g., `'8453'` for Base mainnet) |
| `to` | address | Contract address |
| `value` | string | ETH value in wei |
| `data` | hex | Encoded function call |
| `signerWallet` | address? | Restrict to specific wallet (optional) |

### Signature Types

| Type | Description |
|------|-------------|
| `TYPED_DATA` | EIP-712 structured data (recommended) |
| `PERSONAL_SIGN` | Plain text message signature |

## Utility Functions

### getSmartAccountFromUserId

Get a user's smart account address:

```ts
import { getSmartAccountFromUserId } from '@towns-protocol/bot'

const wallet = await getSmartAccountFromUserId(bot, {
  userId: event.userId
})

if (wallet) {
  // Send tokens, check balances, etc.
}
```

Returns `null` if no smart account exists.

**Use cases:**
- Send tokens/NFTs to users
- Airdrop rewards
- Check balances
- Verify ownership

## Method Selection Guide

| Task | Method | Learn More |
|------|--------|------------|
| Read contract state | `readContract` | - |
| Bot sends transaction | `execute` | - |
| Bot sends batch transactions | `execute` with multiple calls | - |
| User sends transaction | `sendInteractionRequest` (transaction) | - |
| User signs message | `sendInteractionRequest` (signature) | - |
| User clicks button/form | `sendInteractionRequest` (form) | [Interactive Messages](/build/bots/interactive-messages) |
| Bot's SimpleAccount operations | `writeContract` | - |

## Best Practices

### Error Handling

Always check for errors in responses:

```ts
if (response.txHash) {
  // Success
} else if (response.error) {
  // Handle error
  await handler.sendMessage(channelId, `Error: ${response.error}`)
}
```

### Targeting Users

Target specific users for personal interactions:

```ts
await handler.sendInteractionRequest(
  channelId,
  payload,
  hexToBytes(userId as `0x${string}`) // Only this user can interact
)
```

Leave `undefined` for public interactions.

### Unique IDs

Use unique IDs for each interaction to match responses:

```ts
const id = `vote-${Date.now()}-${event.userId}`
```

### Gas Optimization

Batch multiple operations when possible:

```ts
// Good: One transaction
await execute(bot.viem, {
  calls: [approve(), swap(), stake()]
})

// Bad: Three transactions
await execute(bot.viem, { calls: [approve()] })
await execute(bot.viem, { calls: [swap()] })
await execute(bot.viem, { calls: [stake()] })
```

## Next Steps

- Create [interactive messages](/build/bots/interactive-messages) with buttons and forms
- Integrate [external services](/build/bots/external-interactions) via webhooks
- Learn about [slash commands](/build/bots/slash-commands)
- Explore [event handlers](/build/bots/events)

