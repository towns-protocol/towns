---
title: "Towns Encryption Protocol"
description: "Understanding the Towns Encryption and Decryption Protocol"
---

### What is the Towns Encryption Protocol?

The Towns protocol enables end-to-end encryption between groups of user devices. Here's how it works: When a user (Bob) wants to send a message to a group, his device creates a new group session and encrypts the message using an outbound session key before sending it.

When a recipient (Alice) gets the encrypted message, her device will start a
new group session to import the inbound session key, and then use it to decrypt
the message.

How does Alice's device get the inbound session key?

The group encryption protocol works through several key mechanisms. Alice's device sends a `key solicitation request` to obtain any missing session keys. Other group devices can then `share session keys` through `key fulfillment` after verifying Bob's group membership.

Let's examine the core components of the group encryption protocol before exploring the `key solicitation`, `key fulfillment`, and `key sharing` algorithms in detail.

### Core Entities in the Towns Encryption Protocol

` GroupEncryptionCrypto`: The main interface of the protocol. It initializes the `EncryptionDelegate`. This class "delegates" the encryption and decryption operations to the` olm `[**library from the **](https://www.npmjs.com/package/@matrix-org/olm) [**Matrix.org**](http://Matrix.org)[** foundation**](https://www.npmjs.com/package/@matrix-org/olm). This library implements the Double Ratchet algorithm. See notes on [**supported algorithm**](https://docs.towns.com/build/towns-encryption#supported-algorithm) for future plans.

The Towns Encryption Protocol uses this library to create a group session, and
perform device-to-device encryption using the session keys.

The `GroupEncryptionCrypto` creates a `GroupEncryption`, a
`GroupDecryption`, and an `EncryptionDevice` to handle the group encryption
protocol:

```mermaid
---
title: GroupEncryptionCrypto and its embedded components
---
erDiagram
    GroupEncryptionCrypto ||--|| EncryptionDelegate : "initializes"
    GroupEncryptionCrypto ||--|| EncryptionDevice : "creates"
    GroupEncryptionCrypto ||--|| GroupEncryption : "creates"
    GroupEncryptionCrypto ||--|| GroupDecryption : "creates"
    GroupEncryptionCrypto ||--|| CryptoStore : "has reference to"
```

- `GroupEncryption`: Manages group encryption with session keys, encrypting outgoing messages using outbound session keys.
- `GroupDecryption`: Manages group decryption with session keys, decrypting incoming messages using inbound session keys.
- `EncryptionDevice`: Interfaces with the `EncryptionDelegate` for cryptographic operations and uses the `CryptoStore` to manage inbound and outbound session keys.

```mermaid
erDiagram
    GroupEncryption ||--|| EncryptionDevice : "uses for encryption"
    GroupDecryption ||--|| EncryptionDevice : "uses for decryption"
    GroupEncryption ||--|| IGroupEncryptionClient : "uses for key sharing"
    EncryptionDevice ||--|| EncryptionDelegate : "encrypts and decrypts with"
    EncryptionDevice ||--|| CryptoStore : "gets and stores keys in"
```

### Encrypting a message with GroupEncryption

A device will need an outgoing session to encrypt a message to the group. If
it does not already have a session, it must create one. In addition, it will
also create an inbound session. The inbound session is encrypted and sent to
other devices in the group.

```mermaid
flowchart TB
    groupEncryption(encrypt) --> outboundSession{"outbound session exists?"}
    outboundSession -- no --> createOutboundSession("create outbound session")
    createOutboundSession --> saveOutboundSession("save outbound session in CryptoStore")
    outboundSession -- yes --> encrypt("encrypt plaintext with outbound session key")
    encrypt -- returns --> EncryptedData
    saveOutboundSession --> createInboundSession("create inbound session")
    createInboundSession --> saveInboundSession("save inbound session in CryptoStore")
    saveInboundSession --> encryptAndShareInboundSession("encrypt and share inbound session with other devices in group")
    encryptAndShareInboundSession --> encrypt
```

### Decrypting a message with GroupDecryption

```mermaid
flowchart TB
    groupDecryption(decrypt) --> inboundSession{"inbound session exists?"}
    inboundSession -- no --> decryptionError("decryption error")
    inboundSession -- yes --> decrypt("decrypt ciphertext")
    decrypt -- returns --> plaintext
```

### Key solicitation and key fulfillment

If a device does not have any session keys, it can make a `KeySolicitation`
request to the group. Any device that is "online" at that moment can share its
known session keys, and send a `KeyFulfillment` response to inform others in the
group that the `KeySolicitation` request has already been fulfilled.

Continuing our example, suppose Alice's device does not have the session key
to decrypt a message from Bob. Alice's device posts a `KeySolicitation` request
to the stream. Bob's device happens to be online at the moment. When it sees the
request, it processes the request as follows:

```mermaid
flowchart TB
    onKeySolicitation --> userIsEntitledToStream{"is user entitled to read from this stream?"}
    userIsEntitledToStream -- yes --> getSessionKeys("get session keys")
    userIsEntitledToStream -- no --> stop
    getSessionKeys --> sendKeyFulfillment("send key fulfillment to inform the group that the key solicitation was handled")
    sendKeyFulfillment --> encryptAndShareSession("encrypt and share the session keys with the requester")
```

Through this process, Alice's device obtains the required session keys for decryption.

## Build

See [towns-tutorials/encryption-import](https://github.com/river-build/towns-tutorials/tree/main/encryption-import) for a tutorial on how to import the Towns Encryption
npm package.

---

## Footnotes

### Supported algorithm

> The Towns Encryption Protocol is designed to support new algorithms. There is
> an `algorithm` field in the protocol definition. The current value is
> `r.group-encryption.v1.aes-sha2`. This means that the protocol is using the
> `olm` Double Ratchet library for device-to-device session encryption.
> This field can be set to new algorithms to support future needs.

```protobuf
// protocol.proto
message EncryptedData {
    // ...
    /**
    * Encryption algorithm  used to encrypt this event.
    */
    string algorithm = 2;
    // ...
}
```