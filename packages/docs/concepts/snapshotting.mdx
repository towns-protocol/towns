---
title: "Snapshotting"
---

### Event Ordering

Towns nodes assemble events from the stream's `minipool` into `miniblocks`— sealed blocks of event hashes that point to the previous block hash.

While the sequential nature of block production provides basic event ordering, certain events like membership rosters require strict ordering.

Consider this example: Alice `joins` a space at time `t1` and `leaves` at time `t2`. A membership roster read after the `leave` event should exclude Alice. She should appear as a member only during the interval `t2 - t1`, when the `join` and `leave` events were included in mini-blocks. However, since different Towns Nodes may observe these events independently, there's no guarantee they'll be included in mini-blocks in the same temporal sequence as the original actions.

To enforce strict ordering in the Towns protocol, we use **Snapshotting** at each stream's block boundary. This approach has the added benefit of reducing node disk usage since snapshots are updated in-place.

### **Snapshot Production**

Snapshots occur every N events at the block boundary. This happens when a node, elected by `RANDDAO`, proposes the next block by creating and appending a new signed `miniblock` to the stream's `minichain`.

> Though miniblocks contain event hashes, snapshot data remains unhashed in the miniblock to enable fast client syncs of state events from miniblock when rolled up onto Towns Chain.

![Snapshotting](../images/snapshotting.png)

### Data Schema

Any payload type in the protocol may undergo snapshotting. When elected as block proposers, nodes prepare to snapshot events for their assigned streams. This ensures strict ordering of `state` events and other events that require it at the block boundary and data compaction.

Nodes typically store snapshot data in `maps`, as the data naturally fits a `key -> value` structure.

Here is the `Snapshot` message definition from the protocol protobuf that nodes follow:

```protobuf
/**
* Snapshot contains a summary of all state events up to the most recent miniblock
*/
message Snapshot {

    CommonPayload.Snapshot common = 1;

    // Snapshot data specific for each stream type.
    oneof content {
        SpacePayload.Snapshot space_content = 101;
        ChannelPayload.Snapshot channel_content = 102;
        UserPayload.Snapshot user_content = 103;
        UserSettingsPayload.Snapshot user_settings_content = 104;
        UserDeviceKeyPayload.Snapshot user_device_key_content = 105;
        MediaPayload.Snapshot media_content = 106;
        DmChannelPayload.Snapshot dm_channel_content = 107;
        GdmChannelPayload.Snapshot gdm_channel_content = 108;
        UserToDevicePayload.Snapshot user_to_device_content = 109;
    }
}
```

For example, `SpacePayload.Snapshot` defines four maps and an inception event—an immutable singleton for each Space stream. When a node proposes a block for a stream and enough events have accumulated (determined by `MinEventsPerSnapshot` in the stream's inception payload), it creates a snapshot during miniblock construction, updating all four maps and including the modified snapshot object in the miniblock.

> Snapshots occur after accumulating MinEventsPerSnapshot events since the last snapshot because snapshotting is memory-intensive for nodes. Taking snapshots for every event would make miniblock creation as complex as including message events. This batch approach trades strict ordering latency for better node memory efficiency.

```protobuf
message SpacePayload {
    message Snapshot {
        // inception
        Inception inception = 1;
        // streamId: Channel
        map<string, Channel> channels = 2;
        // userId: Membership
        map<string, Membership> memberships = 3;
        // userId: Username
        map<string, WrappedEncryptedData> usernames = 4;
        // userId: Displayname
        map<string, WrappedEncryptedData> display_names = 5;
    }
}
...
```