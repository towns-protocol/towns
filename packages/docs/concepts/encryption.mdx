---
title: "Encryption"
---

### End-to-End Message Encryption in Towns Protocol

All messages in Towns Protocol's communication systems are encrypted. Nodes only see encrypted data (ciphertext), while clients manage their own device encryption keys.

Towns uses two cryptographic ratcheting algorithms for encryption. For peer-to-peer messages, it implements the [**Double Ratchet**](https://signal.org/docs/specifications/doubleratchet/) algorithm from Signal. For group messaging, it uses an optimized AES-based cryptographic ratchet.

### **Devices**

For end-to-end encryption, each `(user, client instance)` pair has a unique `deviceId`. This identifier helps establish peer-to-peer encrypted sessions for sharing group message encryption keys.

Devices are objects that store key material, created on the client and stored in the Towns Node on the user's `UserDeviceKey` stream. Each device contains two key pairs:

1. **Curve25519 peer-to-peer encryption key** - An asymmetric key pair created with each new device. The private key stays on the device, while the public key is stored in the user's `UserDeviceKey` stream. This key, along with the fallback key, enables secure and ephemeral p2p sessions.
2. **Curve25519 fallback key** - A second key pair created using the encryption key and published to the UserDeviceKey stream. To establish a secure p2p session with Bob, Alice uses her encryption key plus Bob's public encryption and fallback keys.

> Device lifecycle management is handled by client implementations, not the Towns protocol. Since the protocol expects a one-to-one relationship between (user, client instance) pairs and devices, the Towns Node regularly compacts the device key stream to prevent unlimited growth.

### **Encryption Data Schemas**

The protocol defines encrypted data (messages or metadata like usernames) using this protobuf message:

```protobuf
message EncryptedData {
    /**
    * Ciphertext of the encryption envelope.
    */
    string ciphertext = 1;
    /**
    * Encryption algorithm  used to encrypt this event.
    */
    string algorithm = 2;
    /**
    * Sender device public key identifying the sender's device.
    */
    string sender_key = 3;
    /**
    * The ID of the session used to encrypt the message.
    */
    string session_id = 4;

    /**
    * Optional checksum of the cleartext data.
    */
    optional string checksum = 5;
}
```

The `session_id` identifies the keys for the ciphertext, enabling multiple decryptions of the same message. This is especially useful in group messaging, as it eliminates the need to create new peer-to-peer encrypted sessions for each message.

Peer-to-peer encryption sessions, used only for transmitting session keys for message events, are defined by this protobuf:

```protobuf
    message GroupEncryptionSessions {
        string stream_id = 1;
        string sender_key = 2;
        repeated string session_ids = 3;
        // deviceKey: per device ciphertext of encrypted session keys that match session_ids
        map<string, string> ciphertexts = 4;
    }
```

The ciphertext is mapped by deviceKey since peer-to-peer encrypted payloads can only be decrypted by the deviceKey for which the `outbound` sender's session was created. Peer-to-peer messages are encrypted on a per-device basis.

### **Encryption Lifecycle**

Here's how encryption works between Alice and Bob, who share a channel in a space:

1. Alice logs in to her client, creates a new `device`, and joins a Space.
2. Bob, already logged in and a Space member, sees a `KeySolicitation` message with Alice's `device_key`.
3. Bob verifies Alice is `isEntitled` to the channel's decryption keys and creates a new p2p encrypted `outbound` session using Alice's device and fallback keys to send the requested keys from his cache.
4. Bob sends an `ack` to notify other channel members that he's handling Alice's request.
5. Alice sees Bob's message in her `UserToDevice` key stream and creates an `inbound` session using Bob's device and fallback keys from his `UserDeviceKey` stream.
6. Alice decrypts Bob's message and stores the key material in her local cache.
7. Alice decrypts channel messages that share the `session_id` of her newly acquired keys.

> Towns requires separate outbound and inbound sessions for encryption and decryption. Each message can be decrypted only once per established session.

### **Key Sharing**

### **Active Sharing**

Clients create session keys for message encryption as needed. When a user first joins a channel and sends a message, they create a new outbound session key to encrypt it and share this with all channel members. Other members can use this same key as an inbound session key to decrypt the message.

### **Passive Sharing**

Passive key sharing helps users obtain keys they're entitled to but don't have locally. When joining a channel, a user needs session keys to decrypt existing messages. The protocol provides an efficient sharing system where users place a `KeySolicitation` event on the stream. Any online member can fulfill this request if the requester has proper entitlements.

### **Data**

Any stream can support key sharing through `KeySolicitation` and `KeyFulfillment` messages. When fulfilling a request, the `device_key` and `fallback_key` are included in the payload to avoid querying the `UserDeviceKey` stream. Members sync fulfillments to prevent duplicate responses to the same request.

```protobuf

    message KeySolicitation {
        string device_key = 1; // requesters device_key
        string fallback_key = 2; // requesters fallback_key
        bool is_new_device = 3; // true if this is a new device, session_ids will be empty
        repeated string session_ids = 4;
    }

    message KeyFulfillment {
        string user_id = 1;
        string device_key = 2;
        repeated string session_ids = 3;
    }
```