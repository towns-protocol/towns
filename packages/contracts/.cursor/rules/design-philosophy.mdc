---
globs: *.sol
alwaysApply: false
---

## Foundational Philosophy: Designing for Simplicity

The primary objective in Towns Protocol development is to **minimize complexity**—anything related to the software structure that makes it hard to understand or modify. In a system as sophisticated as this (with Diamond Pattern upgrades, cross-chain validation, and role-based permissions), managing complexity is critical.

### Core Principles

- **Strategic Programming**: Invest time in design upfront rather than quick tactical fixes. The long-term structure matters more than short-term convenience. Before adding a new facet or feature, design the abstraction carefully.

- **Goal: Obviousness**: Code should be obvious. Developers should quickly understand existing code and confidently make changes. If understanding a facet requires reading multiple files and tracing dependencies, the abstraction is leaking.

- **Eliminate Dependencies**: Minimize coupling between modules. A change in one facet should rarely require changes in others. Use events and interfaces to decouple components.

- **Eliminate Obscurity**: Name entities precisely. Document non-obvious behavior. If a function's purpose isn't clear from its signature and name, the design needs improvement.

- **Avoid Change Amplification**: Small logical changes should not require modifying many files. If adding a permission type requires touching 10+ contracts, the architecture has high coupling.

- **Reduce Cognitive Load**: Developers should not need extensive context to complete tasks. A facet's interface should be self-documenting. Storage layouts should be isolated.

- **No Unknown Unknowns**: It should be obvious which code must be modified for a given change. Clear module boundaries and interfaces prevent hidden dependencies.

### Design Philosophy for Solidity Modules

In this codebase, "modules" refers to contracts, facets, libraries, and functions. Apply these principles at all levels.

## Module Design: Building Deep, Encapsulated Contracts

### 1. Strive for Deep Modules

Contracts and facets should be **deep**: they provide **powerful functionality** through a **simple interface**.

**✅ Deep Module Example (Good):**

```solidity
// Simple interface hiding complex validation
interface IEntitlement {
  function isEntitled(
    bytes32 channelId
    address[] user,
    bytes32 permission
  ) external view returns (bool);
}

// Complex implementation with cross-chain calls, rule evaluation, caching
contract UserEntitlement is IEntitlement {
  // ... 200+ lines of complex logic hidden behind simple interface
}
```

**❌ Shallow Module Example (Bad):**

```solidity
// Interface complexity matches implementation complexity (shallow)
interface IUserHelper {
  function getUserAddress(uint256 userId) external view returns (address);
  function setUserAddress(uint256 userId, address addr) external;
  function deleteUserAddress(uint256 userId) external;
}

// Implementation is just simple CRUD with no abstraction
```

**Guidelines for Deep Modules:**

- **Simple Interface, Complex Implementation**: External functions should be minimal and clear. Internal complexity should be hidden.
- **General Purpose Design**: Design facets to be somewhat general-purpose. Separate specialized logic (e.g., specific entitlement rules) from general mechanisms (e.g., rule evaluation engine).
- **Powerful Abstractions**: A single function like `isEntitled()` can hide rule parsing, external calls, caching, and validation logic.

### 2. Information Hiding and Encapsulation

Information hiding is the most crucial technique for deep facets. In the Diamond Pattern, this is especially important because facets share a proxy but should minimize shared knowledge.

**Prevent Information Leakage:**

- **❌ Leakage**: If the storage layout details of one facet must be known by another facet, that's leakage.
- **✅ Solution**: Each facet has its own isolated storage slot. Facets communicate through libraries, abstracts or well-defined interfaces.

**Example of Information Hiding (Good):**

```solidity
// RewardsDistribution doesn't expose HOW rewards are calculated
function claimRewards(
  address beneficiary,
  address recipient
) external returns (uint256) {
  if (msg.sender == beneficiary) {}
  // If the caller is the authorized claimer, they can claim the reward
  else if (msg.sender == _getAuthorizedClaimer(beneficiary)) {}
  // If the beneficiary is a space, only the operator can claim the reward
  else if (_isSpace(beneficiary)) {
    // the operator may not be active but is still allowed to claim the reward
    address operator = _getOperatorBySpace(beneficiary);
    _revertIfNotOperatorClaimer(operator);
  }
  // If the beneficiary is an operator, only the claimer can claim the reward
  else if (_isOperator(beneficiary)) _revertIfNotOperatorClaimer(beneficiary);
  else RewardsDistribution__NotBeneficiary.selector.revertWith();

  reward = ds.staking.claimReward(beneficiary);
  if (reward != 0) {
    ds.staking.rewardToken.safeTransfer(recipient, reward);
  }
}

// Users call claimRewards() without knowing about operators, space checks, transfers
```

**Example of Information Leakage (Bad):**

```solidity
// Exposing internal structure forces all callers to know implementation details
library SnapshotLib {
    struct Snapshot {
      uint256 amount;
      uint256 timestamp;
    }
}

struct Layout {
  SnapshotLib.Snapshot snapshot
}

function getStakeSnapshots(
  address user
) external returns (SnapshotLib.Snapshot[] memory);

// Now external code must understand snapshot logic, timing windows, etc.
```

### 3. Avoid Temporal Decomposition

Do not structure code solely based on the order of operations. This often creates information leakage and tight coupling.

**❌ Temporal Decomposition (Bad):**

```solidity
contract Step1ValidateUser { ... }
contract Step2CheckPermissions { ... }
contract Step3ExecuteAction { ... }
// Each step exposes intermediate state to the next
```

**✅ Knowledge-Based Organization (Good):**

```solidity
contract PermissionValidator {
  // Contains ALL knowledge about permission validation
  function hasPermission(address user, bytes32 role) external returns (bool) {
    // Internally: validate user, check roles, check entitlements
  }
}

contract ActionExecutor {
  // Contains ALL knowledge about executing actions
  // Depends on PermissionValidator interface, not its implementation
}
```

### 4. Different Layers, Different Abstractions

When tracing an operation through layers, the abstraction should change at each boundary.

**Example of Proper Layering:**

```solidity
// Layer 1: External API (user-facing abstraction)
function createSpace(string memory name) external returns (address) {
  // User thinks: "I'm creating a space with a name"
}

// Layer 2: Factory Logic (deployment abstraction)
function _deploySpace(
  bytes32 salt,
  bytes memory initData
) internal returns (address) {
  // System thinks: "I'm deploying a diamond with initialization data"
}

// Layer 3: Default Role
function _createRole(
  string calldata roleName,
  string[] calldata permissions,
  CreateEntitlement[] calldata entitlements
) {
  // System thinks: "I'm creating a role with entitlements"
}
```

Each layer has a **distinct vocabulary and level of abstraction**. External API uses business terms (spaces, channels). Factory uses deployment terms (diamonds, facets). Low-level code uses EVM terms (delegatecall, storage slots).

### 5. Pull Complexity Downward

When encountering unavoidable complexity, resolve it **within** the module rather than pushing it onto callers.

**❌ Pushing Complexity Up (Bad):**

```solidity
// Caller must understand proof formats, and validation
function upgradeApp(
  address owner,
  bytes32[] memory permissions,
  ExecutionManifest memory manifest,
  uint48 duration
) external returns (bool);
```

**✅ Pulling Complexity Down (Good):**

```solidity
// Simple interface; complexity handled internally
function upgradeApp(
  address app,
  address client,
  bytes32 version
) external returns (bool) {
  // Internally determines owner, permissions, manifest, duration through call to app contract
}
```

## Code Clarity: Naming, Comments, and Error Handling

### 1. Naming Conventions

Names are a form of abstraction and documentation. They create a mental model.

**Precision and Image:**

- Names must be **precise, unambiguous, and intuitive**
- The name should convey what the entity **is** and **is not**
- Avoid vague names like `manager`, `handler`, `helper`, `utils`

**Examples:**

❌ **Vague Names:**

- `manager` → Use `EntitlementsManager` (manages entitlement validation)
- `makeCall()` → Use `delegateToOperator()` (delegates space to operator)
- `data` → Use `ruleEntitlementData` (data for rule-based entitlements)
- `check()` → Use `validateCrossChainPermission()` (validates permission cross-chain)
- `process()` → Use `distributeStakingRewards()` (distributes rewards to stakers)

**Consistency:**

- Use consistent terminology across the codebase
- If you call it a "space" in one place, don't call it a "room" elsewhere
- If a pattern exists (e.g., `FacetNameStorage`, `FacetNameBase`, `FacetNameFacet`), follow it

**Red Flag:** If you struggle to find a simple, precise name, the entity likely has an unclear purpose or poor design.

### 2. Strategic Use of Comments

Comments capture knowledge that cannot be represented in code. They are fundamental to abstraction.

**What to Comment:**

- **The What (Abstraction)**: What does this function/contract provide at a high level?
- **The Why (Rationale)**: Why was this design chosen? What problem does it solve?
- **The Non-Obvious**: What cannot be inferred from the code itself?

**What NOT to Comment:**

- **The How (Implementation)**: The code already shows how it works
- **Redundant Information**: Don't repeat what's in the function name

**Interface Documentation (NatSpec):**

Every public/external function must have NatSpec that defines the abstraction:

```solidity
/// @notice Validates if a user has permission to access a channel
/// @dev This may trigger cross-chain validation if the entitlement
///      is defined on a different chain. Results are cached for efficiency.
/// @param user The address to check permissions for
/// @param channelId The channel identifier
/// @return true if the user has access, false otherwise
function hasChannelAccess(
  address user,
  bytes32 channelId
) external view returns (bool);
```

**Design Tool (Comments First):**

Write **interface comments first** as a design tool before implementing:

1. Write the function signature
2. Write the NatSpec describing what it does (abstraction)
3. If the comment is hard to write or becomes complex, the interface may be wrong
4. Implement the function

This forces you to think about the abstraction before getting lost in implementation details.

**Implementation Comments:**

Use implementation comments sparingly for non-obvious logic:

```solidity
// Checkpoint delegation before transfer to preserve voting power history
_checkpointDelegation(from, to);

// We use unchecked here because the loop counter cannot overflow
// given the maximum array size enforced by MAX_FACETS
unchecked { ++i; }

// Storage slot calculated using ERC-7201 to prevent collisions
bytes32 slot = keccak256(abi.encode(uint256(keccak256("spaces.facet.roles")) - 1))
    & ~bytes32(uint256(0xff));
```

### 3. Handling Errors and Special Cases

Exceptions and special conditions contribute disproportionately to complexity. They force conditional logic throughout the codebase.

**Define Errors Out of Existence:**

Modify semantics so exceptional conditions become normal:

**❌ Special Case (Bad):**

```solidity
function getRoles(
  address user
) external returns (bytes32[] memory roles, bool hasRoles);
// Returns flag indicating if user has roles; caller must check flag
```

**✅ Normal Case (Good):**

```solidity
function getRoles(address user) external returns (bytes32[] memory);
// Returns empty array if no roles; no special flag needed
```

**Reduce Conditionals:**

Eliminating special cases reduces `if` statement proliferation:

**❌ Many Special Cases (Bad):**

```solidity
function calculateReward(address user) external returns (uint256) {
  if (!isStaker(user)) revert NotStaker();
  if (isPaused()) revert SystemPaused();
  if (lastClaimTime[user] == 0) {
    // Special initialization logic
  }
  if (stakes[user] == 0) return 0; // Special case for zero stake
  if (block.timestamp < vestingStart) return 0; // Special case for vesting
  // ... more special cases
}
```

**✅ Unified Logic (Good):**

```solidity
function calculateReward(address user) external returns (uint256) {
  // Design so zero stake naturally returns zero
  // Design so unvested time naturally returns zero
  // No special cases needed
  return _computeTimeWeightedReward(stakes[user], lastClaimTime[user]);
}
```

**Exception Masking:**

Handle exceptions low in the system to hide them from higher layers:

```solidity
// Low-level function masks missing data by returning empty array
function _getCrossChainRules(uint256 chainId) internal returns (Rule[] memory) {
  try crossChainValidator.getRules(chainId) returns (Rule[] memory rules) {
    return rules;
  } catch {
    return new Rule[](0); // Mask exception; return empty array
  }
}

// High-level function doesn't need to handle missing data case
function validateAllRules(address user) external returns (bool) {
  Rule[] memory rules = _getCrossChainRules(currentChain);
  // Empty array is handled naturally in loop
  for (uint256 i; i < rules.length; ++i) {
    if (!_evaluate(rules[i], user)) return false;
  }
  return true;
}
```

**Exception Aggregation:**

Handle many exceptions with a single generic handler at a higher level:

```solidity
// Instead of handling each entitlement type's error separately
function checkAllPermissions(address user) external returns (bool) {
  try permisionChecker.check(user) returns (bool result) {
    return result;
  } catch {
    // Aggregate all entitlement failures into one handler
    emit EntitlementCheckFailed(user);
    return false;
  }
}
```

## Design Process and Red Flags

### Design It Twice

For major design decisions (new facets, public APIs, core abstractions), consider **at least two radically different approaches**:

**Example: Designing Delegation System**

**Option 1: Direct Delegation**

- Users directly delegate to operators
- Pros: Simple, gas efficient, clear ownership
- Cons: No intermediary layer, harder to add features later

**Option 2: Proxy-Based Delegation**

- Users delegate through proxy contracts
- Pros: Flexible, can add delegation logic, supports future features
- Cons: More complex, higher gas costs, additional contracts

**Option 3: Space-Mediated Delegation**

- Users delegate to spaces, spaces delegate to operators
- Pros: Aligns with space model, allows space-level policies
- Cons: Adds indirection, more complex reward distribution

Evaluate trade-offs explicitly. Document the decision rationale in comments or docs.

### Red Flags: Warning Signs of Poor Design

- **Shallow Module**: Interface complexity rivals implementation complexity. The module doesn't hide much.

  - _Example_: A facet with 20 external functions that are mostly simple CRUD operations with no abstractions.

- **Information Leakage**: The same knowledge/decision is reflected in multiple modules.

  - _Example_: Storage layout changes in one facet require changes in another facet. Multiple contracts need to understand data format.

- **Pass-Through Method**: Function does nothing but call another function with similar signature.

  - _Example_: `function getVotes(address a) external { return votesModule.getVotes(a); }` (adds no value, poor division of labor)

- **Vague Name**: Name is imprecise and doesn't convey useful information.

  - _Example_: `processData()`, `handleRequest()`, `manager`, `helper`, `utils`

- **Special-General Mixture**: Module mixes general mechanisms with specialized code for one use case.

  - _Example_: A general entitlement checker that has hardcoded logic for one specific NFT collection.

- **Conjoined Methods**: Two methods are commonly called together; their signatures are related.

  - _Example_: Always calling `updateUserData()` and then `syncUserState()` suggests they should be one method.

- **Comment Describes Implementation**: Comment explains what code is doing rather than why or what abstraction it provides.

  - _Example_: `// Loop through users and check their balance` (obvious from code)

- **Hard to Name**: Difficulty finding a clear name for a module, function, or variable.

  - _Example_: Suggests the entity has unclear purpose or tries to do too many unrelated things.

- **Unknown Unknowns**: It's not obvious what must be modified for a change.
  - _Example_: Adding a permission type requires mysterious changes across facets because dependencies aren't clear.

### Refactoring Triggers

If you encounter these red flags, consider refactoring:

1. **Extract General Mechanism**: Separate general-purpose code from specialized use cases
2. **Merge Related Modules**: If two modules share too much knowledge, merge them
3. **Split Unrelated Concerns**: If a module does too many things, split it
4. **Improve Interface**: If interface is complex, find a simpler abstraction
5. **Hide Information**: If implementation details leak, add an abstraction layer

## Summary: Principles in Practice

When designing or modifying Towns Protocol contracts:

1. **Think Strategically**: Invest in design upfront; prioritize long-term structure
2. **Design Deep Modules**: Simple interfaces, powerful implementations
3. **Hide Information**: Minimize coupling; isolate knowledge in modules
4. **Use Precise Names**: Names should create clear mental models
5. **Document Abstractions**: Write comments that describe what and why, not how
6. **Eliminate Special Cases**: Design so edge cases are handled uniformly
7. **Design It Twice**: Consider alternatives for major decisions
8. **Watch for Red Flags**: Shallow modules, information leakage, vague names

These principles compound. Well-designed abstractions make the codebase easier to understand, modify, and extend—crucial for a complex, upgradeable system like Towns Protocol.
